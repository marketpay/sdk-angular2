/**
 * MarketPay API
 * API for Smart Contracts and Payments
 *
 * OpenAPI spec version: v2.01
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class UsersApi {
    protected basePath = 'https://localhost/';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * View a User
     * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
     * @param userId The Id of a user
     */
    public usersGet(userId: number, extraHttpRequestParams?: any): Observable<models.UserResponse> {
        return this.usersGetWithHttpInfo(userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * View a Bank Account
     * 
     * @param userId The Id of a user
     * @param bankAccountId The Id of a bank account
     */
    public usersGetBankAccount(userId: number, bankAccountId: number, extraHttpRequestParams?: any): Observable<models.BankAccountResponse> {
        return this.usersGetBankAccountWithHttpInfo(userId, bankAccountId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List Bank Accounts for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetBankAccountList(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Array<models.BankAccountResponse>> {
        return this.usersGetBankAccountListWithHttpInfo(userId, page, perPage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List Cards for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetCardList(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Array<models.CardResponse>> {
        return this.usersGetCardListWithHttpInfo(userId, page, perPage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * View a Legal User
     * 
     * @param userId The Id of a legal user
     */
    public usersGetLegal(userId: number, extraHttpRequestParams?: any): Observable<models.UserLegalResponse> {
        return this.usersGetLegalWithHttpInfo(userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List all Users
     * 
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetList(page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Array<models.UserResponse>> {
        return this.usersGetListWithHttpInfo(page, perPage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * View a Natural User
     * 
     * @param userId The Id of a natural user
     */
    public usersGetNatural(userId: number, extraHttpRequestParams?: any): Observable<models.UserNaturalResponse> {
        return this.usersGetNaturalWithHttpInfo(userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List Transactions for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetTransactionList(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Array<models.TransactionResponse>> {
        return this.usersGetTransactionListWithHttpInfo(userId, page, perPage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List Wallets for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetWalletList(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Array<models.WalletResponse>> {
        return this.usersGetWalletListWithHttpInfo(userId, page, perPage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a CA BankAccount
     * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
     * @param userId The Id of a user
     * @param bankAccountCA BankAccountCA Object params
     */
    public usersPostBankAccountCa(userId: number, bankAccountCA?: models.BankAccountCaPost, extraHttpRequestParams?: any): Observable<models.BankAccountResponseCa> {
        return this.usersPostBankAccountCaWithHttpInfo(userId, bankAccountCA, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a GB BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountGB 
     */
    public usersPostBankAccountGb(userId: number, bankAccountGB?: models.BankAccountGbPost, extraHttpRequestParams?: any): Observable<models.BankAccountResponseGb> {
        return this.usersPostBankAccountGbWithHttpInfo(userId, bankAccountGB, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an IBAN BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountIBAN BankAccountIBAN Object params
     */
    public usersPostBankAccountIban(userId: number, bankAccountIBAN?: models.BankAccountIbanPost, extraHttpRequestParams?: any): Observable<models.BankAccountResponseIban> {
        return this.usersPostBankAccountIbanWithHttpInfo(userId, bankAccountIBAN, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an OTHER BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountOTHER 
     */
    public usersPostBankAccountOther(userId: number, bankAccountOTHER?: models.BankAccountOtherPost, extraHttpRequestParams?: any): Observable<models.BankAccountResponseOther> {
        return this.usersPostBankAccountOtherWithHttpInfo(userId, bankAccountOTHER, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an US BankAccount
     * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
     * @param userId The Id of a user
     * @param bankAccountUS BankAccountUS Object params
     */
    public usersPostBankAccountUs(userId: number, bankAccountUS?: models.BankAccountUsPost, extraHttpRequestParams?: any): Observable<models.BankAccountResponseUs> {
        return this.usersPostBankAccountUsWithHttpInfo(userId, bankAccountUS, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userLegal UserLegal Object params
     */
    public usersPostLegal(userLegal?: models.UserLegalPost, extraHttpRequestParams?: any): Observable<models.UserLegalResponse> {
        return this.usersPostLegalWithHttpInfo(userLegal, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userNatural UserNatural Object params
     */
    public usersPostNatural(userNatural?: models.UserNaturalPost, extraHttpRequestParams?: any): Observable<models.UserNaturalResponse> {
        return this.usersPostNaturalWithHttpInfo(userNatural, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userLegal UserLegal Object params
     */
    public usersPutLegal(userId: number, userLegal?: models.UserLegalPut, extraHttpRequestParams?: any): Observable<models.UserLegalResponse> {
        return this.usersPutLegalWithHttpInfo(userId, userLegal, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userNatural UserNatural Object params
     */
    public usersPutNatural(userId: number, userNatural?: models.UserNaturalPut, extraHttpRequestParams?: any): Observable<models.UserNaturalResponse> {
        return this.usersPutNaturalWithHttpInfo(userId, userNatural, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * View a User
     * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
     * @param userId The Id of a user
     */
    public usersGetWithHttpInfo(userId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * View a Bank Account
     * 
     * @param userId The Id of a user
     * @param bankAccountId The Id of a bank account
     */
    public usersGetBankAccountWithHttpInfo(userId: number, bankAccountId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/${BankAccountId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetBankAccount.');
        }
        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling usersGetBankAccount.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Bank Accounts for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetBankAccountListWithHttpInfo(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetBankAccountList.');
        }
        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('Page', <any>page.d.toISOString());
            } else {
                queryParameters.set('Page', <any>page);
            }
        }

        if (perPage !== undefined) {
            if(perPage instanceof Date) {
                queryParameters.set('Per_Page', <any>perPage.d.toISOString());
            } else {
                queryParameters.set('Per_Page', <any>perPage);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Cards for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetCardListWithHttpInfo(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/cards`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetCardList.');
        }
        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('Page', <any>page.d.toISOString());
            } else {
                queryParameters.set('Page', <any>page);
            }
        }

        if (perPage !== undefined) {
            if(perPage instanceof Date) {
                queryParameters.set('Per_Page', <any>perPage.d.toISOString());
            } else {
                queryParameters.set('Per_Page', <any>perPage);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * View a Legal User
     * 
     * @param userId The Id of a legal user
     */
    public usersGetLegalWithHttpInfo(userId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/legal/${UserId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetLegal.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List all Users
     * 
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetListWithHttpInfo(page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('Page', <any>page.d.toISOString());
            } else {
                queryParameters.set('Page', <any>page);
            }
        }

        if (perPage !== undefined) {
            if(perPage instanceof Date) {
                queryParameters.set('Per_Page', <any>perPage.d.toISOString());
            } else {
                queryParameters.set('Per_Page', <any>perPage);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * View a Natural User
     * 
     * @param userId The Id of a natural user
     */
    public usersGetNaturalWithHttpInfo(userId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/natural/${UserId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetNatural.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Transactions for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetTransactionListWithHttpInfo(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/transactions`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetTransactionList.');
        }
        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('Page', <any>page.d.toISOString());
            } else {
                queryParameters.set('Page', <any>page);
            }
        }

        if (perPage !== undefined) {
            if(perPage instanceof Date) {
                queryParameters.set('Per_Page', <any>perPage.d.toISOString());
            } else {
                queryParameters.set('Per_Page', <any>perPage);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Wallets for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    public usersGetWalletListWithHttpInfo(userId: number, page?: number, perPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/wallets`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersGetWalletList.');
        }
        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('Page', <any>page.d.toISOString());
            } else {
                queryParameters.set('Page', <any>page);
            }
        }

        if (perPage !== undefined) {
            if(perPage instanceof Date) {
                queryParameters.set('Per_Page', <any>perPage.d.toISOString());
            } else {
                queryParameters.set('Per_Page', <any>perPage);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a CA BankAccount
     * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
     * @param userId The Id of a user
     * @param bankAccountCA BankAccountCA Object params
     */
    public usersPostBankAccountCaWithHttpInfo(userId: number, bankAccountCA?: models.BankAccountCaPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/CA`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPostBankAccountCa.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bankAccountCA == null ? '' : JSON.stringify(bankAccountCA), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a GB BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountGB 
     */
    public usersPostBankAccountGbWithHttpInfo(userId: number, bankAccountGB?: models.BankAccountGbPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/GB`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPostBankAccountGb.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bankAccountGB == null ? '' : JSON.stringify(bankAccountGB), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an IBAN BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountIBAN BankAccountIBAN Object params
     */
    public usersPostBankAccountIbanWithHttpInfo(userId: number, bankAccountIBAN?: models.BankAccountIbanPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/IBAN`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPostBankAccountIban.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bankAccountIBAN == null ? '' : JSON.stringify(bankAccountIBAN), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an OTHER BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountOTHER 
     */
    public usersPostBankAccountOtherWithHttpInfo(userId: number, bankAccountOTHER?: models.BankAccountOtherPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/OTHER`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPostBankAccountOther.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bankAccountOTHER == null ? '' : JSON.stringify(bankAccountOTHER), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an US BankAccount
     * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
     * @param userId The Id of a user
     * @param bankAccountUS BankAccountUS Object params
     */
    public usersPostBankAccountUsWithHttpInfo(userId: number, bankAccountUS?: models.BankAccountUsPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/${UserId}/bankaccounts/US`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPostBankAccountUs.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bankAccountUS == null ? '' : JSON.stringify(bankAccountUS), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userLegal UserLegal Object params
     */
    public usersPostLegalWithHttpInfo(userLegal?: models.UserLegalPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/legal`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: userLegal == null ? '' : JSON.stringify(userLegal), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userNatural UserNatural Object params
     */
    public usersPostNaturalWithHttpInfo(userNatural?: models.UserNaturalPost, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/natural`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: userNatural == null ? '' : JSON.stringify(userNatural), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userLegal UserLegal Object params
     */
    public usersPutLegalWithHttpInfo(userId: number, userLegal?: models.UserLegalPut, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/legal/${UserId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPutLegal.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: userLegal == null ? '' : JSON.stringify(userLegal), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userNatural UserNatural Object params
     */
    public usersPutNaturalWithHttpInfo(userId: number, userNatural?: models.UserNaturalPut, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v2.01/Users/natural/${UserId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPutNatural.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'text/json', 
            'application/json-patch+json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: userNatural == null ? '' : JSON.stringify(userNatural), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
