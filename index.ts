/**
 * MarketPay API
 * API for Smart Contracts and Payments
 *
 * OpenAPI spec version: v2.01
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Address {
    /**
     * The first line of the address
     */
    "addressLine1": string;
    /**
     * The second line of the address
     */
    "addressLine2"?: string;
    /**
     * The city of the address
     */
    "city": string;
    /**
     * The region of the address - this is optional except if the Country is US, CA or MX
     */
    "region"?: string;
    /**
     * The postal code of the address - can be alphanumeric, dashes or spaces
     */
    "postalCode": string;
    /**
     * The Country where the bank account is held
     */
    "country": AddressCountryEnum;
}

export type AddressCountryEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface AplazameOrderItem {
    "id"?: string;
    "name": string;
    "url"?: string;
    "imageUrl"?: string;
    "quantity"?: number;
    "price": number;
    "description"?: string;
    "taxRate"?: number;
}

export interface AplazamePayByWebPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * Whether to save or not the card for future use. SaveCard and CardId are mutually exclusive
     */
    "userId"?: number;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds": Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    "shipping"?: Money;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá en caso de error en el pago.
     */
    "cancelUrl": string;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá cuando se haya completado el pago.
     */
    "successUrl": string;
    /**
     * Dirección a la que se redirigirá el usuario si escoge volver a la tienda (por omisión '/').
     */
    "checkoutUrl"?: string;
    "orderItems": Array<AplazameOrderItem>;
    /**
     * Customer data.  Optional user info. If it is not set, Marketpay will try to use the data it does currently have about the user, but it will fail if existing data is not enough.
     */
    "customer": Customer;
}

export interface AplazamePayByWebResponse {
    "payInId"?: string;
    "checkoutData"?: string;
}

export interface AplazamePayInsResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: AplazamePayInsResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: AplazamePayInsResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: AplazamePayInsResponseTypeEnum;
    /**
     * The type of payin
     */
    "paymentType"?: AplazamePayInsResponsePaymentTypeEnum;
    /**
     * The type of execution for the payin
     */
    "executionType"?: AplazamePayInsResponseExecutionTypeEnum;
    /**
     * The Id of the card saved, if any.
     */
    "cardId"?: string;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type AplazamePayInsResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type AplazamePayInsResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type AplazamePayInsResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type AplazamePayInsResponsePaymentTypeEnum = "NotSpecified" | "CARD" | "BANK_WIRE" | "DIRECT_DEBIT" | "PREAUTHORIZED";
export type AplazamePayInsResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface AplazameRefundPaymentPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    "debitedFunds": Money;
    "fees": Money;
}

export interface AplazameRefundResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: AplazameRefundResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: AplazameRefundResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: AplazameRefundResponseTypeEnum;
    /**
     * The initial transaction ID
     */
    "initialTransactionId"?: string;
    /**
     * The initial transaction type
     */
    "initialTransactionType"?: AplazameRefundResponseInitialTransactionTypeEnum;
    /**
     * Contains info about the reason for refund
     */
    "refundReason"?: RefundReason;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type AplazameRefundResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type AplazameRefundResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type AplazameRefundResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type AplazameRefundResponseInitialTransactionTypeEnum = "NotSpecified" | "PAYIN" | "TRANSFER" | "PAYOUT";
export interface BankAccountCaPost {
    /**
     * The branch code of the bank where the bank account. Must be numbers only, and 5 digits long
     */
    "branchCode"?: string;
    /**
     * The institution number of the bank account. Must be numbers only, and 3 or 4 digits long
     */
    "institutionNumber"?: string;
    /**
     * The account number of the bank account. Must be numbers only. Canadian account numbers must be a maximum of 20 digits
     */
    "accountNumber"?: string;
    /**
     * The name of the bank where the account is held. Must be letters or numbers only and maximum 50 characters long
     */
    "bankName"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
}

export interface BankAccountGbPost {
    /**
     * The sort code of the bank account. Must be numbers only, and 6 digits long
     */
    "sortCode"?: string;
    /**
     * The account number of the bank account. Must be numbers only. GB account numbers must be 8 digits long
     */
    "accountNumber"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
}

export interface BankAccountIbanPost {
    /**
     * The IBAN of the bank account
     */
    "iBAN"?: string;
    /**
     * The BIC of the bank account
     */
    "bIC"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
}

export interface BankAccountOtherPost {
    /**
     * The Country where the bank account is held
     */
    "country"?: BankAccountOtherPostCountryEnum;
    /**
     * The BIC of the bank account
     */
    "bIC"?: string;
    /**
     * The account number of the bank account. Must be numbers only. Canadian account numbers must be a maximum of 20 digits
     */
    "accountNumber"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
}

export type BankAccountOtherPostCountryEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface BankAccountResponse {
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountResponseCa {
    /**
     * The branch code of the bank where the bank account. Must be numbers only, and 5 digits long
     */
    "branchCode"?: string;
    /**
     * The institution number of the bank account. Must be numbers only, and 3 or 4 digits long
     */
    "institutionNumber"?: string;
    /**
     * The account number of the bank account. Must be numbers only. Canadian account numbers must be a maximum of 20 digits
     */
    "accountNumber"?: string;
    /**
     * The name of the bank where the account is held. Must be letters or numbers only and maximum 50 characters long
     */
    "bankName"?: string;
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseCaTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseCaTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountResponseGb {
    /**
     * The sort code of the bank account. Must be numbers only, and 6 digits long
     */
    "sortCode"?: string;
    /**
     * The account number of the bank account. Must be numbers only. GB account numbers must be 8 digits long
     */
    "accountNumber"?: string;
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseGbTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseGbTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountResponseIban {
    /**
     * The IBAN of the bank account
     */
    "iBAN"?: string;
    /**
     * The BIC of the bank account
     */
    "bIC"?: string;
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseIbanTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseIbanTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountResponseOther {
    /**
     * The Country where the bank account is held
     */
    "country"?: BankAccountResponseOtherCountryEnum;
    /**
     * The BIC of the bank account
     */
    "bIC"?: string;
    /**
     * The account number of the bank account. Must be numbers only. Canadian account numbers must be a maximum of 20 digits
     */
    "accountNumber"?: string;
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseOtherTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseOtherCountryEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type BankAccountResponseOtherTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountResponseUs {
    /**
     * The account number of the bank account. US account numbers must be digits only
     */
    "accountNumber"?: string;
    /**
     * The ABA of the bank account. Must be numbers only, and 9 digits long
     */
    "aBA"?: string;
    /**
     * The type of account
     */
    "depositAccountType"?: BankAccountResponseUsDepositAccountTypeEnum;
    /**
     * The type of bank account
     */
    "type"?: BankAccountResponseUsTypeEnum;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * Whether the bank account is active or not
     */
    "active"?: boolean;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankAccountResponseUsDepositAccountTypeEnum = "NotSpecified" | "CHECKING" | "SAVINGS";
export type BankAccountResponseUsTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountType {
    "type"?: BankAccountTypeTypeEnum;
    "ownerAddress"?: Address;
    "ownerName"?: string;
    "iBAN"?: string;
    "bIC"?: string;
}

export type BankAccountTypeTypeEnum = "IBAN" | "GB" | "US" | "CA" | "OTHER";
export interface BankAccountUsPost {
    /**
     * The account number of the bank account. US account numbers must be digits only
     */
    "accountNumber"?: string;
    /**
     * The ABA of the bank account. Must be numbers only, and 9 digits long
     */
    "aBA"?: string;
    /**
     * The type of account
     */
    "depositAccountType"?: BankAccountUsPostDepositAccountTypeEnum;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The address of the owner of the bank account
     */
    "ownerAddress"?: Address;
    /**
     * The name of the owner of the bank account
     */
    "ownerName"?: string;
}

export type BankAccountUsPostDepositAccountTypeEnum = "NotSpecified" | "CHECKING" | "SAVINGS";
export interface BankwirePayInPayInPost {
    "tag"?: string;
    "creditedWalletId": string;
    "debitedFunds": Money;
    "fees": Money;
}

export interface BankwirePayInPayInResponse {
    "debitedFunds"?: Money;
    "creditedFunds"?: Money;
    "fees"?: Money;
    "creditedWalletId"?: string;
    "nature"?: BankwirePayInPayInResponseNatureEnum;
    "status"?: BankwirePayInPayInResponseStatusEnum;
    "executionDate"?: number;
    "resultCode"?: string;
    "resultMessage"?: string;
    "type"?: BankwirePayInPayInResponseTypeEnum;
    "paymentType"?: BankwirePayInPayInResponsePaymentTypeEnum;
    "executionType"?: BankwirePayInPayInResponseExecutionTypeEnum;
    "authorId"?: string;
    "creditedUserId"?: string;
    "wireReference"?: string;
    "bankAccount"?: BankAccountType;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type BankwirePayInPayInResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type BankwirePayInPayInResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type BankwirePayInPayInResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type BankwirePayInPayInResponsePaymentTypeEnum = "NotSpecified" | "CARD" | "BANK_WIRE" | "DIRECT_DEBIT" | "PREAUTHORIZED";
export type BankwirePayInPayInResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface CardPut {
    /**
     * Whether the card is active or not
     */
    "active"?: boolean;
}

export interface CardResponse {
    /**
     * The object owner's UserId
     */
    "userId"?: string;
    /**
     * The expiry date of the card - must be in format MMYY
     */
    "expirationDate"?: string;
    /**
     * A partially obfuscated version of the credit card number
     */
    "alias"?: string;
    /**
     * The provider of the card
     */
    "cardProvider"?: string;
    /**
     * The type of card
     */
    "cardType"?: CardResponseCardTypeEnum;
    /**
     * The Country where the bank account is held
     */
    "country"?: string;
    /**
     * The card product type
     */
    "product"?: string;
    /**
     * 
     */
    "bankCode"?: string;
    /**
     * Whether the card is active or not
     */
    "active"?: boolean;
    /**
     * The currency - should be ISO_4217 format
     */
    "currency"?: CardResponseCurrencyEnum;
    /**
     * Whether the card is valid or not. Once they process (or attempt to process) a payment with the card we are able to indicate if it is \"valid\" or \"invalid\". If they didn’t process a payment yet the \"Validity\" stay at \"unknown\"
     */
    "validity"?: CardResponseValidityEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type CardResponseCardTypeEnum = "NotSpecified" | "CB_VISA_MASTERCARD" | "AMEX" | "DINERS" | "MASTERPASS" | "MAESTRO" | "P24" | "IDEAL" | "BCMC" | "PAYLIB";
export type CardResponseCurrencyEnum = "NotSpecified" | "XXX" | "AED" | "AFN" | "ALL" | "AMD" | "ANG" | "AOA" | "ARS" | "AUD" | "AWG" | "AZN" | "BAM" | "BBD" | "BDT" | "BGN" | "BHD" | "BIF" | "BMD" | "BND" | "BOB" | "BOV" | "BRL" | "BSD" | "BTN" | "BWP" | "BYR" | "BZD" | "CAD" | "CDF" | "CHE" | "CHF" | "CHW" | "CLF" | "CLP" | "CNY" | "COP" | "COU" | "CRC" | "CUC" | "CUP" | "CVE" | "CZK" | "DJF" | "DKK" | "DOP" | "DZD" | "EGP" | "ERN" | "ETB" | "EUR" | "FJD" | "FKP" | "GBP" | "GEL" | "GHS" | "GIP" | "GMD" | "GNF" | "GTQ" | "GYD" | "HKD" | "HNL" | "HRK" | "HTG" | "HUF" | "IDR" | "ILS" | "INR" | "IQD" | "IRR" | "ISK" | "JMD" | "JOD" | "JPY" | "KES" | "KGS" | "KHR" | "KMF" | "KPW" | "KRW" | "KWD" | "KYD" | "KZT" | "LAK" | "LBP" | "LKR" | "LRD" | "LSL" | "LTL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "USS" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAF" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XBT" | "XCD" | "XDR" | "XFU" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "YER" | "ZAR" | "ZMW" | "ZWD";
export type CardResponseValidityEnum = "NotSpecified" | "UNKNOWN" | "VALID" | "INVALID";
export interface CustomApiErrorResponse {
    "message"?: string;
    "type"?: string;
    "id"?: string;
    "date"?: number;
    "errors"?: { [key: string]: string; };
}

export interface Customer {
    "email": string;
    "firstName"?: string;
    "lastName"?: string;
    "telephone"?: Telephone;
    "address": Address;
}

export interface CustomerDetail {
    "firstName"?: string;
    "lastName"?: string;
    "telephone"?: Telephone;
    "address": Address;
}

export interface ExampleUserNaturalPost {
}

export interface Money {
    /**
     * The currency - should be ISO_4217 format
     */
    "currency"?: MoneyCurrencyEnum;
    /**
     * An amount of money in cents, e.g. 12.60€ would be represented as 1260
     */
    "amount"?: number;
}

export type MoneyCurrencyEnum = "NotSpecified" | "XXX" | "AED" | "AFN" | "ALL" | "AMD" | "ANG" | "AOA" | "ARS" | "AUD" | "AWG" | "AZN" | "BAM" | "BBD" | "BDT" | "BGN" | "BHD" | "BIF" | "BMD" | "BND" | "BOB" | "BOV" | "BRL" | "BSD" | "BTN" | "BWP" | "BYR" | "BZD" | "CAD" | "CDF" | "CHE" | "CHF" | "CHW" | "CLF" | "CLP" | "CNY" | "COP" | "COU" | "CRC" | "CUC" | "CUP" | "CVE" | "CZK" | "DJF" | "DKK" | "DOP" | "DZD" | "EGP" | "ERN" | "ETB" | "EUR" | "FJD" | "FKP" | "GBP" | "GEL" | "GHS" | "GIP" | "GMD" | "GNF" | "GTQ" | "GYD" | "HKD" | "HNL" | "HRK" | "HTG" | "HUF" | "IDR" | "ILS" | "INR" | "IQD" | "IRR" | "ISK" | "JMD" | "JOD" | "JPY" | "KES" | "KGS" | "KHR" | "KMF" | "KPW" | "KRW" | "KWD" | "KYD" | "KZT" | "LAK" | "LBP" | "LKR" | "LRD" | "LSL" | "LTL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "USS" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAF" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XBT" | "XCD" | "XDR" | "XFU" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "YER" | "ZAR" | "ZMW" | "ZWD";
export interface PayOutBankWirePost {
    "tag"?: string;
    "debitedFunds"?: Money;
    "fees"?: Money;
    "bankAccountId"?: string;
    "debitedWalletId"?: string;
    "bankWireRef"?: string;
}

export interface PayOutBankWireResponse {
    "authorId"?: string;
    "creditedUserId"?: string;
    "debitedFunds"?: Money;
    "creditedFunds"?: Money;
    "fees"?: Money;
    "status"?: PayOutBankWireResponseStatusEnum;
    "resultCode"?: string;
    "resultMessage"?: string;
    "executionDate"?: number;
    "type"?: PayOutBankWireResponseTypeEnum;
    "nature"?: PayOutBankWireResponseNatureEnum;
    "debitedWalletId"?: string;
    "creditedWalletId"?: string;
    "paymentType"?: PayOutBankWireResponsePaymentTypeEnum;
    "bankAccountId"?: string;
    "bankWireRef"?: string;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type PayOutBankWireResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type PayOutBankWireResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type PayOutBankWireResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type PayOutBankWireResponsePaymentTypeEnum = "NotSpecified" | "BANK_WIRE";
export interface PaymentRedsysData {
    "dsOrder"?: string;
    "dsAuthorisationCode"?: string;
}

export interface PaymentUniversalPayData {
    "transactionId"?: string;
}

export interface PreauthorizationRedsysData {
    "dsOrder"?: string;
    "dsAuthorisationCode"?: string;
}

export interface Product {
    "insuredValue"?: number;
}

export interface RedsysPayByWebPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * Whether to save or not the card for future use. SaveCard and CardId are mutually exclusive
     */
    "saveCard"?: boolean;
    /**
     * The id of a previous saved card. SaveCard and CardId are mutually exclusive
     */
    "cardId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId": string;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá cuando se haya completado el pago.
     */
    "successUrl": string;
    /**
     * Url to redirect the browser in case the payment is completed successfully
     */
    "urlOk"?: string;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá en caso de error en el pago.
     */
    "cancelUrl": string;
    /**
     * Url to redirect the browser in case the payment is not completed successfully
     */
    "urlKo"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds": Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees": Money;
}

export interface RedsysPayByWebResponse {
    /**
     * Id of the payment
     */
    "payInId"?: string;
    /**
     * Url to post from the user's browser
     */
    "url"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsSignatureVersion"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsMerchantParameters"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsSignature"?: string;
}

export interface RedsysPayInsResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: RedsysPayInsResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: RedsysPayInsResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: RedsysPayInsResponseTypeEnum;
    /**
     * The type of payin
     */
    "paymentType"?: RedsysPayInsResponsePaymentTypeEnum;
    /**
     * The type of execution for the payin
     */
    "executionType"?: RedsysPayInsResponseExecutionTypeEnum;
    /**
     * The Id of the card saved, if any.
     */
    "cardId"?: string;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * Redsys related data
     */
    "provider"?: PaymentRedsysData;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type RedsysPayInsResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type RedsysPayInsResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type RedsysPayInsResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type RedsysPayInsResponsePaymentTypeEnum = "NotSpecified" | "CARD" | "BANK_WIRE" | "DIRECT_DEBIT" | "PREAUTHORIZED";
export type RedsysPayInsResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface RedsysPreauthorizationCancellationPost {
}

export interface RedsysPreauthorizationCancellationResponse {
}

export interface RedsysPreauthorizationConfirmationPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * Information about the funds that are being debited. This value must be equal o less than the value informed at the Preauthorization creation
     */
    "debitedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
}

export interface RedsysPreauthorizationConfirmationResponse {
    /**
     * Id of the payment
     */
    "payInId"?: string;
}

export interface RedsysPreauthorizeByWebPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * Whether to save or not the card for future use. SaveCard and CardId are mutually exclusive
     */
    "saveCard"?: boolean;
    /**
     * The id of a previous saved card. SaveCard and CardId are mutually exclusive
     */
    "cardId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá cuando se haya completado el pago.
     */
    "successUrl": string;
    /**
     * Url to redirect the browser in case the payment is completed successfully
     */
    "urlOk"?: string;
    /**
     * Dirección (relativa a la tienda) a la que redirigirá en caso de error en el pago.
     */
    "cancelUrl": string;
    /**
     * Url to redirect the browser in case the payment is not completed successfully
     */
    "urlKo"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
}

export interface RedsysPreauthorizeByWebResponse {
    /**
     * Id of the preauthorization
     */
    "preauthorizationId"?: string;
    /**
     * Url to post from the user's browser
     */
    "url"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsSignatureVersion"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsMerchantParameters"?: string;
    /**
     * This paramater must be include in the Post to the Url
     */
    "dsSignature"?: string;
}

export interface RedsysPreauthorizeResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * The status of the transaction
     */
    "status"?: RedsysPreauthorizeResponseStatusEnum;
    /**
     * Status of the payment
     */
    "paymentStatus"?: RedsysPreauthorizeResponsePaymentStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of execution for the payin
     */
    "executionType"?: RedsysPreauthorizeResponseExecutionTypeEnum;
    /**
     * The Id of the card saved, if any.
     */
    "cardId"?: string;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The Id of the associated PayIn
     */
    "payInId"?: string;
    /**
     * Redsys related data
     */
    "provider"?: PreauthorizationRedsysData;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type RedsysPreauthorizeResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type RedsysPreauthorizeResponsePaymentStatusEnum = "NotSpecified" | "WAITING" | "CANCELED" | "EXPIRED" | "VALIDATED";
export type RedsysPreauthorizeResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface RedsysRefundPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
}

export interface RedsysRefundResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: RedsysRefundResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: RedsysRefundResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: RedsysRefundResponseTypeEnum;
    /**
     * The initial transaction ID
     */
    "initialTransactionId"?: string;
    /**
     * The initial transaction type
     */
    "initialTransactionType"?: RedsysRefundResponseInitialTransactionTypeEnum;
    /**
     * Contains info about the reason for refund
     */
    "refundReason"?: RefundReason;
    /**
     * Redsys related data
     */
    "provider"?: RefundRedsysData;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type RedsysRefundResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type RedsysRefundResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type RedsysRefundResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type RedsysRefundResponseInitialTransactionTypeEnum = "NotSpecified" | "PAYIN" | "TRANSFER" | "PAYOUT";
export interface RefundReason {
    /**
     * The type of reason for refusal
     */
    "type"?: RefundReasonTypeEnum;
    /**
     * The message accompanying a refusal
     */
    "message"?: string;
}

export type RefundReasonTypeEnum = "NotSpecified" | "BANKACCOUNT_INCORRECT" | "BANKACCOUNT_HAS_BEEN_CLOSED" | "OWNER_DOT_NOT_MATCH_BANKACCOUNT" | "WITHDRAWAL_IMPOSSIBLE_ON_SAVINGS_ACCOUNTS" | "INITIALIZED_BY_CLIENT" | "OTHER";
export interface RefundRedsysData {
    "dsOrder"?: string;
    "dsAuthorisationCode"?: string;
}

export interface ResponseListCardResponse {
    "values"?: Array<CardResponse>;
    "total"?: number;
}

export interface ResponseListTransactionResponse {
    "values"?: Array<TransactionResponse>;
    "total"?: number;
}

export interface ResponseListTransferResponse {
    "values"?: Array<TransferResponse>;
    "total"?: number;
}

export interface ResponseListWalletResponse {
    "values"?: Array<WalletResponse>;
    "total"?: number;
}

export interface SeurShipmentCancellationResponse {
    /**
     * 
     */
    "status"?: SeurShipmentCancellationResponseStatusEnum;
}

export type SeurShipmentCancellationResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED" | "CANCELED";
export interface SeurShipmentPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * 
     */
    "pickUpDate"?: number;
    /**
     * 
     */
    "sender"?: ShipmentActor;
    /**
     * 
     */
    "receiver"?: ShipmentActor;
    /**
     * The ID of the user sending the package
     */
    "senderUserId"?: string;
    /**
     * The ID of the user sending the package
     */
    "receiverUserId"?: string;
    /**
     * 
     */
    "product"?: Product;
}

export interface SeurShipmentResponse {
    /**
     * NumRecogida. Utilizar el id de base de datos
     */
    "locatorNumber"?: string;
    /**
     * Tasacion
     */
    "quotation"?: number;
    /**
     * The status of the transaction
     */
    "status"?: SeurShipmentResponseStatusEnum;
    /**
     * 
     */
    "statusPickUp"?: SeurShipmentResponseStatusPickUpEnum;
    /**
     * 
     */
    "statusPickUpCode"?: string;
    /**
     * 
     */
    "statusDelivery"?: SeurShipmentResponseStatusDeliveryEnum;
    /**
     * 
     */
    "statusDeliveryCode"?: string;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type SeurShipmentResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED" | "CANCELED";
export type SeurShipmentResponseStatusPickUpEnum = "Unknown" | "Ready" | "Started" | "Failed" | "Picked";
export type SeurShipmentResponseStatusDeliveryEnum = "Unknown" | "Ready" | "Delivered";
export interface ShipmentActor {
    "name"?: string;
    "telephone"?: TelephoneSeur;
    "address"?: Address;
}

export interface Telephone {
    "countryCode"?: string;
    "number"?: string;
}

export interface TelephoneSeur {
    /**
     * This field is deprecated. Use CountryCode instead
     */
    "prefix"?: string;
    "countryCode"?: string;
    "number"?: string;
}

export interface TokenUniversalPayData {
    "transactionId"?: string;
}

export interface TransactionResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: TransactionResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: TransactionResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: TransactionResponseTypeEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type TransactionResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type TransactionResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type TransactionResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export interface TransferPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
}

export interface TransferResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: TransferResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: TransferResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: TransferResponseTypeEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type TransferResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type TransferResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type TransferResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export interface UniversalPayPayByWebPost {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds": Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees": Money;
    "cardId"?: string;
    "saveCard"?: boolean;
    "statementDescriptor": string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId": string;
    "secureMode"?: UniversalPayPayByWebPostSecureModeEnum;
    /**
     * Url to redirect the browser in case the payment is completed successfully
     */
    "successUrl"?: string;
    /**
     * Url to redirect the browser in case the payment is not completed successfully
     */
    "cancelUrl"?: string;
    /**
     * Valid values are ES, EN, FR
     */
    "language"?: UniversalPayPayByWebPostLanguageEnum;
    "customer": CustomerDetail;
}

export type UniversalPayPayByWebPostSecureModeEnum = "NotSpecified" | "DEFAULT" | "FORCE";
export type UniversalPayPayByWebPostLanguageEnum = "NotSpecified" | "DE" | "EN" | "DA" | "ES" | "ET" | "FI" | "FR" | "EL" | "HU" | "IT" | "NL" | "NO" | "PL" | "PT" | "SK" | "SV" | "CS";
export interface UniversalPayPayByWebResponse {
    /**
     * Id of the payment
     */
    "payInId"?: string;
    "url"?: string;
}

export interface UniversalPayPayInsResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: UniversalPayPayInsResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: UniversalPayPayInsResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: UniversalPayPayInsResponseTypeEnum;
    /**
     * The type of payin
     */
    "paymentType"?: UniversalPayPayInsResponsePaymentTypeEnum;
    /**
     * The type of execution for the payin
     */
    "executionType"?: UniversalPayPayInsResponseExecutionTypeEnum;
    /**
     * A custom description to appear on the user's bank statement. It can be up to 10 characters long, and can only include alphanumeric characters or spaces
     */
    "statementDescriptor"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    "provider"?: PaymentUniversalPayData;
    "cardId"?: string;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type UniversalPayPayInsResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type UniversalPayPayInsResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type UniversalPayPayInsResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type UniversalPayPayInsResponsePaymentTypeEnum = "NotSpecified" | "CARD" | "BANK_WIRE" | "DIRECT_DEBIT" | "PREAUTHORIZED";
export type UniversalPayPayInsResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface UniversalPayRefundPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    "statementDescription"?: string;
}

export interface UniversalPayRefundResponse {
    /**
     * Information about the funds that are being debited
     */
    "debitedFunds"?: Money;
    /**
     * Details about the funds that are being credited (DebitedFunds – Fees = CreditedFunds)
     */
    "creditedFunds"?: Money;
    /**
     * Information about the fees that were taken by the client for this transaction (and were hence transferred to the Client's platform wallet)
     */
    "fees"?: Money;
    /**
     * The ID of the wallet that was debited
     */
    "debitedWalletId"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId"?: string;
    /**
     * A user's ID
     */
    "authorId"?: string;
    /**
     * The user ID who was credited
     */
    "creditedUserId"?: string;
    /**
     * The nature of the transaction
     */
    "nature"?: UniversalPayRefundResponseNatureEnum;
    /**
     * The status of the transaction
     */
    "status"?: UniversalPayRefundResponseStatusEnum;
    /**
     * When the transaction happened
     */
    "executionDate"?: number;
    /**
     * The result code
     */
    "resultCode"?: string;
    /**
     * A verbal explanation of the ResultCode
     */
    "resultMessage"?: string;
    /**
     * The type of the transaction
     */
    "type"?: UniversalPayRefundResponseTypeEnum;
    /**
     * The initial transaction ID
     */
    "initialTransactionId"?: string;
    /**
     * The initial transaction type
     */
    "initialTransactionType"?: UniversalPayRefundResponseInitialTransactionTypeEnum;
    /**
     * Contains info about the reason for refund
     */
    "refundReason"?: RefundReason;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type UniversalPayRefundResponseNatureEnum = "REGULAR" | "REFUND" | "REPUDIATION" | "SETTLEMENT";
export type UniversalPayRefundResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type UniversalPayRefundResponseTypeEnum = "PAYIN" | "PAYOUT" | "TRANSFER";
export type UniversalPayRefundResponseInitialTransactionTypeEnum = "NotSpecified" | "PAYIN" | "TRANSFER" | "PAYOUT";
export interface UniversalPayTokenRequestPost {
    "authorizationFunds"?: Money;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * The ID of the wallet where money will be credited
     */
    "creditedWalletId": string;
    "secureMode"?: UniversalPayTokenRequestPostSecureModeEnum;
    /**
     * Url to redirect the browser in case the payment is completed successfully
     */
    "successUrl"?: string;
    /**
     * Url to redirect the browser in case the payment is not completed successfully
     */
    "cancelUrl"?: string;
    /**
     * Valid values are ES, EN, FR
     */
    "language"?: UniversalPayTokenRequestPostLanguageEnum;
    "customer": CustomerDetail;
}

export type UniversalPayTokenRequestPostSecureModeEnum = "NotSpecified" | "DEFAULT" | "FORCE";
export type UniversalPayTokenRequestPostLanguageEnum = "NotSpecified" | "DE" | "EN" | "DA" | "ES" | "ET" | "FI" | "FR" | "EL" | "HU" | "IT" | "NL" | "NO" | "PL" | "PT" | "SK" | "SV" | "CS";
export interface UniversalPayTokenizationResponse {
    "creditedWalletId"?: string;
    "status"?: UniversalPayTokenizationResponseStatusEnum;
    "executionDate"?: number;
    "resultCode"?: string;
    "resultMessage"?: string;
    "executionType"?: UniversalPayTokenizationResponseExecutionTypeEnum;
    "authorId"?: string;
    "creditedUserId"?: string;
    "provider"?: TokenUniversalPayData;
    "cardId"?: string;
}

export type UniversalPayTokenizationResponseStatusEnum = "CREATED" | "SUCCEEDED" | "FAILED";
export type UniversalPayTokenizationResponseExecutionTypeEnum = "NotSpecified" | "WEB" | "DIRECT";
export interface UniversalPayTokenizeByWebResponse {
    "tokenId"?: string;
    "url"?: string;
}

export interface UserLegalPost {
    /**
     * he address of the company’s headquarters
     */
    "headquartersAddress"?: Address;
    /**
     * The type of legal user
     */
    "legalPersonType"?: UserLegalPostLegalPersonTypeEnum;
    /**
     * The name of the legal user
     */
    "name"?: string;
    /**
     * The address of the company’s Legal representative person
     */
    "legalRepresentativeAddress"?: Address;
    /**
     * The date of birth of the company’s Legal representative person - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "legalRepresentativeBirthday"?: number;
    /**
     * The country of residence of the company’s Legal representative person
     */
    "legalRepresentativeCountryOfResidence"?: UserLegalPostLegalRepresentativeCountryOfResidenceEnum;
    /**
     * The nationality of the company’s Legal representative person
     */
    "legalRepresentativeNationality"?: UserLegalPostLegalRepresentativeNationalityEnum;
    /**
     * The email of the company’s Legal representative person - must be a valid
     */
    "legalRepresentativeEmail"?: string;
    /**
     * The firstname of the company’s Legal representative person
     */
    "legalRepresentativeFirstName"?: string;
    /**
     * The lastname of the company’s Legal representative person
     */
    "legalRepresentativeLastName"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
}

export type UserLegalPostLegalPersonTypeEnum = "BUSINESS" | "ORGANIZATION" | "SOLETRADER";
export type UserLegalPostLegalRepresentativeCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserLegalPostLegalRepresentativeNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface UserLegalPut {
    /**
     * he address of the company’s headquarters
     */
    "headquartersAddress"?: Address;
    /**
     * The type of legal user
     */
    "legalPersonType"?: UserLegalPutLegalPersonTypeEnum;
    /**
     * The name of the legal user
     */
    "name"?: string;
    /**
     * The address of the company’s Legal representative person
     */
    "legalRepresentativeAddress"?: Address;
    /**
     * The date of birth of the company’s Legal representative person - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "legalRepresentativeBirthday"?: number;
    /**
     * The country of residence of the company’s Legal representative person
     */
    "legalRepresentativeCountryOfResidence"?: UserLegalPutLegalRepresentativeCountryOfResidenceEnum;
    /**
     * The nationality of the company’s Legal representative person
     */
    "legalRepresentativeNationality"?: UserLegalPutLegalRepresentativeNationalityEnum;
    /**
     * The email of the company’s Legal representative person - must be a valid
     */
    "legalRepresentativeEmail"?: string;
    /**
     * The firstname of the company’s Legal representative person
     */
    "legalRepresentativeFirstName"?: string;
    /**
     * The lastname of the company’s Legal representative person
     */
    "legalRepresentativeLastName"?: string;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
}

export type UserLegalPutLegalPersonTypeEnum = "BUSINESS" | "ORGANIZATION" | "SOLETRADER";
export type UserLegalPutLegalRepresentativeCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserLegalPutLegalRepresentativeNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface UserLegalResponse {
    /**
     * The address of the company’s headquarters
     */
    "headquartersAddress"?: Address;
    /**
     * The type of legal user
     */
    "legalPersonType"?: UserLegalResponseLegalPersonTypeEnum;
    /**
     * The name of the legal user
     */
    "name"?: string;
    /**
     * The address of the company’s Legal representative person
     */
    "legalRepresentativeAddress"?: Address;
    /**
     * The date of birth of the company’s Legal representative person - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "legalRepresentativeBirthday"?: number;
    /**
     * The country of residence of the company’s Legal representative person
     */
    "legalRepresentativeCountryOfResidence"?: UserLegalResponseLegalRepresentativeCountryOfResidenceEnum;
    /**
     * The nationality of the company’s Legal representative person
     */
    "legalRepresentativeNationality"?: UserLegalResponseLegalRepresentativeNationalityEnum;
    /**
     * The email of the company’s Legal representative person - must be a valid
     */
    "legalRepresentativeEmail"?: string;
    /**
     * The firstname of the company’s Legal representative person
     */
    "legalRepresentativeFirstName"?: string;
    /**
     * The lastname of the company’s Legal representative person
     */
    "legalRepresentativeLastName"?: string;
    /**
     * Legal Representative Proof Of Identity
     */
    "legalRepresentativeProofOfIdentity"?: string;
    /**
     * Statute
     */
    "statute"?: string;
    /**
     * Shareholder declaration
     */
    "shareholderDeclaration"?: string;
    /**
     * Proof of registration
     */
    "proofOfRegistration"?: string;
    /**
     * Type of user
     */
    "personType"?: UserLegalResponsePersonTypeEnum;
    /**
     * 
     */
    "kYCLevel"?: UserLegalResponseKYCLevelEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type UserLegalResponseLegalPersonTypeEnum = "BUSINESS" | "ORGANIZATION" | "SOLETRADER";
export type UserLegalResponseLegalRepresentativeCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserLegalResponseLegalRepresentativeNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserLegalResponsePersonTypeEnum = "Natural" | "Legal" | "Fees";
export type UserLegalResponseKYCLevelEnum = "NotSpecified" | "LIGHT" | "REGULAR";
export interface UserNaturalPost {
    /**
     * The user's email address - must be a valid email
     */
    "email"?: string;
    /**
     * The name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The address
     */
    "address"?: Address;
    /**
     * The date of birth of the user - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "birthday"?: number;
    /**
     * The user’s nationality. ISO 3166-1 alpha-2 format is expected
     */
    "nationality"?: UserNaturalPostNationalityEnum;
    /**
     * The user’s country of residence. ISO 3166-1 alpha-2 format is expected
     */
    "countryOfResidence"?: UserNaturalPostCountryOfResidenceEnum;
    /**
     * User’s occupation, ie. Work
     */
    "occupation"?: string;
    /**
     * Could be only one of these values: 1 - for incomes &lt;18K€),2 - for incomes between 18 and 30K€, 3 - for incomes between 30 and 50K€, 4 - for incomes between 50 and 80K€, 5 - for incomes between 80 and 120K€, 6 - for incomes &gt;120K€
     */
    "incomeRange"?: number;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
}

export type UserNaturalPostNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserNaturalPostCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface UserNaturalPut {
    /**
     * The user's email address - must be a valid email
     */
    "email"?: string;
    /**
     * The name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The address
     */
    "address"?: Address;
    /**
     * The date of birth of the user - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "birthday"?: number;
    /**
     * The user’s nationality. ISO 3166-1 alpha-2 format is expected
     */
    "nationality"?: UserNaturalPutNationalityEnum;
    /**
     * The user’s country of residence. ISO 3166-1 alpha-2 format is expected
     */
    "countryOfResidence"?: UserNaturalPutCountryOfResidenceEnum;
    /**
     * User’s occupation, ie. Work
     */
    "occupation"?: string;
    /**
     * Could be only one of these values: 1 - for incomes &lt;18K€),2 - for incomes between 18 and 30K€, 3 - for incomes between 30 and 50K€, 4 - for incomes between 50 and 80K€, 5 - for incomes between 80 and 120K€, 6 - for incomes &gt;120K€
     */
    "incomeRange"?: number;
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
}

export type UserNaturalPutNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserNaturalPutCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export interface UserNaturalResponse {
    /**
     * The user's email address - must be a valid email
     */
    "email"?: string;
    /**
     * The name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The address
     */
    "address"?: Address;
    /**
     * The date of birth of the user - be careful to set the right timezone (should be UTC) to avoid 00h becoming 23h (and hence interpreted as the day before)
     */
    "birthday"?: number;
    /**
     * The user’s nationality. ISO 3166-1 alpha-2 format is expected
     */
    "nationality"?: UserNaturalResponseNationalityEnum;
    /**
     * The user’s country of residence. ISO 3166-1 alpha-2 format is expected
     */
    "countryOfResidence"?: UserNaturalResponseCountryOfResidenceEnum;
    /**
     * User’s occupation, ie. Work
     */
    "occupation"?: string;
    /**
     * Could be only one of these values: 1 - for incomes &lt;18K€),2 - for incomes between 18 and 30K€, 3 - for incomes between 30 and 50K€, 4 - for incomes between 50 and 80K€, 5 - for incomes between 80 and 120K€, 6 - for incomes &gt;120K€
     */
    "incomeRange"?: number;
    /**
     * Proof of identity.
     */
    "proofOfIdentity"?: string;
    /**
     * Proof of address.
     */
    "proofOfAddress"?: string;
    /**
     * Type of user
     */
    "personType"?: UserNaturalResponsePersonTypeEnum;
    /**
     * 
     */
    "kYCLevel"?: UserNaturalResponseKYCLevelEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type UserNaturalResponseNationalityEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserNaturalResponseCountryOfResidenceEnum = "NotSpecified" | "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
export type UserNaturalResponsePersonTypeEnum = "Natural" | "Legal" | "Fees";
export type UserNaturalResponseKYCLevelEnum = "NotSpecified" | "LIGHT" | "REGULAR";
export interface UserResponse {
    /**
     * Type of user
     */
    "personType"?: UserResponsePersonTypeEnum;
    /**
     * 
     */
    "kYCLevel"?: UserResponseKYCLevelEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type UserResponsePersonTypeEnum = "Natural" | "Legal" | "Fees";
export type UserResponseKYCLevelEnum = "NotSpecified" | "LIGHT" | "REGULAR";
export interface WalletPost {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * An array of userIDs of who own's the wallet. For now, you only can set up a unique owner
     */
    "owners": Array<string>;
    /**
     * A desciption of the wallet
     */
    "description"?: string;
    /**
     * The currency - should be ISO_4217 format
     */
    "currency"?: WalletPostCurrencyEnum;
}

export type WalletPostCurrencyEnum = "NotSpecified" | "XXX" | "AED" | "AFN" | "ALL" | "AMD" | "ANG" | "AOA" | "ARS" | "AUD" | "AWG" | "AZN" | "BAM" | "BBD" | "BDT" | "BGN" | "BHD" | "BIF" | "BMD" | "BND" | "BOB" | "BOV" | "BRL" | "BSD" | "BTN" | "BWP" | "BYR" | "BZD" | "CAD" | "CDF" | "CHE" | "CHF" | "CHW" | "CLF" | "CLP" | "CNY" | "COP" | "COU" | "CRC" | "CUC" | "CUP" | "CVE" | "CZK" | "DJF" | "DKK" | "DOP" | "DZD" | "EGP" | "ERN" | "ETB" | "EUR" | "FJD" | "FKP" | "GBP" | "GEL" | "GHS" | "GIP" | "GMD" | "GNF" | "GTQ" | "GYD" | "HKD" | "HNL" | "HRK" | "HTG" | "HUF" | "IDR" | "ILS" | "INR" | "IQD" | "IRR" | "ISK" | "JMD" | "JOD" | "JPY" | "KES" | "KGS" | "KHR" | "KMF" | "KPW" | "KRW" | "KWD" | "KYD" | "KZT" | "LAK" | "LBP" | "LKR" | "LRD" | "LSL" | "LTL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "USS" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAF" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XBT" | "XCD" | "XDR" | "XFU" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "YER" | "ZAR" | "ZMW" | "ZWD";
export interface WalletPut {
    /**
     * Custom data that you can add to this item
     */
    "tag"?: string;
    /**
     * A desciption of the wallet
     */
    "description"?: string;
}

export interface WalletResponse {
    /**
     * An array of userIDs of who own's the wallet. For now, you only can set up a unique owner
     */
    "owners"?: Array<string>;
    /**
     * The current balance of the wallet
     */
    "balance"?: Money;
    /**
     * The type of funds in the wallet
     */
    "fundsType"?: WalletResponseFundsTypeEnum;
    /**
     * A desciption of the wallet
     */
    "description"?: string;
    /**
     * The currency - should be ISO_4217 format
     */
    "currency"?: WalletResponseCurrencyEnum;
    "id"?: string;
    "creationDate"?: number;
    "tag"?: string;
}

export type WalletResponseFundsTypeEnum = "NotSpecified" | "DEFAULT" | "FEES" | "CREDIT";
export type WalletResponseCurrencyEnum = "NotSpecified" | "XXX" | "AED" | "AFN" | "ALL" | "AMD" | "ANG" | "AOA" | "ARS" | "AUD" | "AWG" | "AZN" | "BAM" | "BBD" | "BDT" | "BGN" | "BHD" | "BIF" | "BMD" | "BND" | "BOB" | "BOV" | "BRL" | "BSD" | "BTN" | "BWP" | "BYR" | "BZD" | "CAD" | "CDF" | "CHE" | "CHF" | "CHW" | "CLF" | "CLP" | "CNY" | "COP" | "COU" | "CRC" | "CUC" | "CUP" | "CVE" | "CZK" | "DJF" | "DKK" | "DOP" | "DZD" | "EGP" | "ERN" | "ETB" | "EUR" | "FJD" | "FKP" | "GBP" | "GEL" | "GHS" | "GIP" | "GMD" | "GNF" | "GTQ" | "GYD" | "HKD" | "HNL" | "HRK" | "HTG" | "HUF" | "IDR" | "ILS" | "INR" | "IQD" | "IRR" | "ISK" | "JMD" | "JOD" | "JPY" | "KES" | "KGS" | "KHR" | "KMF" | "KPW" | "KRW" | "KWD" | "KYD" | "KZT" | "LAK" | "LBP" | "LKR" | "LRD" | "LSL" | "LTL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "USS" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAF" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XBT" | "XCD" | "XDR" | "XFU" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "YER" | "ZAR" | "ZMW" | "ZWD";


/**
 * CardsApi - fetch parameter creator
 */
export const CardsApiFetchParamCreator = {
    /** 
     * View a Card
     * In order to save cards, the next methods are currently available:              - Redsys Payment: Set the value of the SaveCard to true.              - Redsys Preauthorization: Set the value of the SaveCard to true.              In order to use previously saved cards, the next methods are currently available:              - Redsys Payment: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited.              - Redsys Preauthorization: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited once the preauthorization is confirmed.
     * @param cardId The Id of a card
     */
    cardsGet(params: {  "cardId": number; }, options?: any): FetchArgs {
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling cardsGet");
        }
        const baseUrl = `/v2.01/Cards/{CardId}`
            .replace(`{${"CardId"}}`, `${ params["cardId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    cardsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Cards`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Deactivate a Card
     * Note that once deactivated, a card can&#39;t be reactivated afterwards
     * @param cardId The Id of a card
     * @param card Card Object params
     */
    cardsPut(params: {  "cardId": number; "card"?: CardPut; }, options?: any): FetchArgs {
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling cardsPut");
        }
        const baseUrl = `/v2.01/Cards/{CardId}`
            .replace(`{${"CardId"}}`, `${ params["cardId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["card"]) {
            fetchOptions.body = JSON.stringify(params["card"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CardsApi - functional programming interface
 */
export const CardsApiFp = {
    /** 
     * View a Card
     * In order to save cards, the next methods are currently available:              - Redsys Payment: Set the value of the SaveCard to true.              - Redsys Preauthorization: Set the value of the SaveCard to true.              In order to use previously saved cards, the next methods are currently available:              - Redsys Payment: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited.              - Redsys Preauthorization: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited once the preauthorization is confirmed.
     * @param cardId The Id of a card
     */
    cardsGet(params: { "cardId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
        const fetchArgs = CardsApiFetchParamCreator.cardsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    cardsGetList(params: { "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseListCardResponse> {
        const fetchArgs = CardsApiFetchParamCreator.cardsGetList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Deactivate a Card
     * Note that once deactivated, a card can&#39;t be reactivated afterwards
     * @param cardId The Id of a card
     * @param card Card Object params
     */
    cardsPut(params: { "cardId": number; "card"?: CardPut;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
        const fetchArgs = CardsApiFetchParamCreator.cardsPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CardsApi - object-oriented interface
 */
export class CardsApi extends BaseAPI {
    /** 
     * View a Card
     * In order to save cards, the next methods are currently available:              - Redsys Payment: Set the value of the SaveCard to true.              - Redsys Preauthorization: Set the value of the SaveCard to true.              In order to use previously saved cards, the next methods are currently available:              - Redsys Payment: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited.              - Redsys Preauthorization: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited once the preauthorization is confirmed.
     * @param cardId The Id of a card
     */
    cardsGet(params: {  "cardId": number; }, options?: any) {
        return CardsApiFp.cardsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param page 
     * @param perPage 
     */
    cardsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
        return CardsApiFp.cardsGetList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Deactivate a Card
     * Note that once deactivated, a card can&#39;t be reactivated afterwards
     * @param cardId The Id of a card
     * @param card Card Object params
     */
    cardsPut(params: {  "cardId": number; "card"?: CardPut; }, options?: any) {
        return CardsApiFp.cardsPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CardsApi - factory interface
 */
export const CardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a Card
         * In order to save cards, the next methods are currently available:              - Redsys Payment: Set the value of the SaveCard to true.              - Redsys Preauthorization: Set the value of the SaveCard to true.              In order to use previously saved cards, the next methods are currently available:              - Redsys Payment: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited.              - Redsys Preauthorization: Set the value of CardId. The card must belong to the user that owns the wallet where the payment will be credited once the preauthorization is confirmed.
         * @param cardId The Id of a card
         */
        cardsGet(params: {  "cardId": number; }, options?: any) {
            return CardsApiFp.cardsGet(params, options)(fetch, basePath);
        },
        /** 
         * @param page 
         * @param perPage 
         */
        cardsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
            return CardsApiFp.cardsGetList(params, options)(fetch, basePath);
        },
        /** 
         * Deactivate a Card
         * Note that once deactivated, a card can&#39;t be reactivated afterwards
         * @param cardId The Id of a card
         * @param card Card Object params
         */
        cardsPut(params: {  "cardId": number; "card"?: CardPut; }, options?: any) {
            return CardsApiFp.cardsPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayInsAplazameApi - fetch parameter creator
 */
export const PayInsAplazameApiFetchParamCreator = {
    /** 
     * -------
     * 
     * @param payInId ------
     */
    payInsAplazameAplazameGetPayment(params: {  "payInId": string; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsAplazameAplazameGetPayment");
        }
        const baseUrl = `/v2.01/PayInsAplazame/payments/{PayInId}`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * --------
     * 
     * @param aplazamePayIn ------------
     */
    payInsAplazameAplazamePostPaymentByWeb(params: {  "aplazamePayIn"?: AplazamePayByWebPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsAplazame/payments/web`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aplazamePayIn"]) {
            fetchOptions.body = JSON.stringify(params["aplazamePayIn"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param payInId 
     * @param aplazameRefund 
     */
    payInsAplazameRefund(params: {  "payInId": string; "aplazameRefund"?: AplazameRefundPaymentPost; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsAplazameRefund");
        }
        const baseUrl = `/v2.01/PayInsAplazame/payments/{PayInId}/refunds`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["aplazameRefund"]) {
            fetchOptions.body = JSON.stringify(params["aplazameRefund"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayInsAplazameApi - functional programming interface
 */
export const PayInsAplazameApiFp = {
    /** 
     * -------
     * 
     * @param payInId ------
     */
    payInsAplazameAplazameGetPayment(params: { "payInId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AplazamePayInsResponse> {
        const fetchArgs = PayInsAplazameApiFetchParamCreator.payInsAplazameAplazameGetPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * --------
     * 
     * @param aplazamePayIn ------------
     */
    payInsAplazameAplazamePostPaymentByWeb(params: { "aplazamePayIn"?: AplazamePayByWebPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AplazamePayByWebResponse> {
        const fetchArgs = PayInsAplazameApiFetchParamCreator.payInsAplazameAplazamePostPaymentByWeb(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param payInId 
     * @param aplazameRefund 
     */
    payInsAplazameRefund(params: { "payInId": string; "aplazameRefund"?: AplazameRefundPaymentPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AplazameRefundResponse> {
        const fetchArgs = PayInsAplazameApiFetchParamCreator.payInsAplazameRefund(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayInsAplazameApi - object-oriented interface
 */
export class PayInsAplazameApi extends BaseAPI {
    /** 
     * -------
     * 
     * @param payInId ------
     */
    payInsAplazameAplazameGetPayment(params: {  "payInId": string; }, options?: any) {
        return PayInsAplazameApiFp.payInsAplazameAplazameGetPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * --------
     * 
     * @param aplazamePayIn ------------
     */
    payInsAplazameAplazamePostPaymentByWeb(params: {  "aplazamePayIn"?: AplazamePayByWebPost; }, options?: any) {
        return PayInsAplazameApiFp.payInsAplazameAplazamePostPaymentByWeb(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param payInId 
     * @param aplazameRefund 
     */
    payInsAplazameRefund(params: {  "payInId": string; "aplazameRefund"?: AplazameRefundPaymentPost; }, options?: any) {
        return PayInsAplazameApiFp.payInsAplazameRefund(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayInsAplazameApi - factory interface
 */
export const PayInsAplazameApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * -------
         * 
         * @param payInId ------
         */
        payInsAplazameAplazameGetPayment(params: {  "payInId": string; }, options?: any) {
            return PayInsAplazameApiFp.payInsAplazameAplazameGetPayment(params, options)(fetch, basePath);
        },
        /** 
         * --------
         * 
         * @param aplazamePayIn ------------
         */
        payInsAplazameAplazamePostPaymentByWeb(params: {  "aplazamePayIn"?: AplazamePayByWebPost; }, options?: any) {
            return PayInsAplazameApiFp.payInsAplazameAplazamePostPaymentByWeb(params, options)(fetch, basePath);
        },
        /** 
         * @param payInId 
         * @param aplazameRefund 
         */
        payInsAplazameRefund(params: {  "payInId": string; "aplazameRefund"?: AplazameRefundPaymentPost; }, options?: any) {
            return PayInsAplazameApiFp.payInsAplazameRefund(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayInsBankwireApi - fetch parameter creator
 */
export const PayInsBankwireApiFetchParamCreator = {
    /** 
     * @param payInId 
     */
    payInsBankwireBankwireGetPayment(params: {  "payInId": number; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsBankwireBankwireGetPayment");
        }
        const baseUrl = `/v2.01/PayInsBankwire/payments/{PayInId}`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param bankwirePayIn 
     */
    payInsBankwireBankwirePaymentByDirect(params: {  "bankwirePayIn"?: BankwirePayInPayInPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsBankwire/payments/direct`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankwirePayIn"]) {
            fetchOptions.body = JSON.stringify(params["bankwirePayIn"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayInsBankwireApi - functional programming interface
 */
export const PayInsBankwireApiFp = {
    /** 
     * @param payInId 
     */
    payInsBankwireBankwireGetPayment(params: { "payInId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankwirePayInPayInResponse> {
        const fetchArgs = PayInsBankwireApiFetchParamCreator.payInsBankwireBankwireGetPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param bankwirePayIn 
     */
    payInsBankwireBankwirePaymentByDirect(params: { "bankwirePayIn"?: BankwirePayInPayInPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankwirePayInPayInResponse> {
        const fetchArgs = PayInsBankwireApiFetchParamCreator.payInsBankwireBankwirePaymentByDirect(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayInsBankwireApi - object-oriented interface
 */
export class PayInsBankwireApi extends BaseAPI {
    /** 
     * @param payInId 
     */
    payInsBankwireBankwireGetPayment(params: {  "payInId": number; }, options?: any) {
        return PayInsBankwireApiFp.payInsBankwireBankwireGetPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param bankwirePayIn 
     */
    payInsBankwireBankwirePaymentByDirect(params: {  "bankwirePayIn"?: BankwirePayInPayInPost; }, options?: any) {
        return PayInsBankwireApiFp.payInsBankwireBankwirePaymentByDirect(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayInsBankwireApi - factory interface
 */
export const PayInsBankwireApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param payInId 
         */
        payInsBankwireBankwireGetPayment(params: {  "payInId": number; }, options?: any) {
            return PayInsBankwireApiFp.payInsBankwireBankwireGetPayment(params, options)(fetch, basePath);
        },
        /** 
         * @param bankwirePayIn 
         */
        payInsBankwireBankwirePaymentByDirect(params: {  "bankwirePayIn"?: BankwirePayInPayInPost; }, options?: any) {
            return PayInsBankwireApiFp.payInsBankwireBankwirePaymentByDirect(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayInsRedsysApi - fetch parameter creator
 */
export const PayInsRedsysApiFetchParamCreator = {
    /** 
     * View a Redsys payment
     * 
     * @param payInId The Id of a payment
     */
    payInsRedsysRedsysGetPayment(params: {  "payInId": number; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsRedsysRedsysGetPayment");
        }
        const baseUrl = `/v2.01/PayInsRedsys/payments/{PayInId}`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * View a Redsys Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys Preauthorization
     */
    payInsRedsysRedsysGetPreauthorization(params: {  "preauthorizationId": number; }, options?: any): FetchArgs {
        // verify required parameter "preauthorizationId" is set
        if (params["preauthorizationId"] == null) {
            throw new Error("Missing required parameter preauthorizationId when calling payInsRedsysRedsysGetPreauthorization");
        }
        const baseUrl = `/v2.01/PayInsRedsys/preauthorizations/{PreauthorizationId}`
            .replace(`{${"PreauthorizationId"}}`, `${ params["preauthorizationId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Redsys PayIn Request
     * Prepares a payment on Redsys. The data returned is used to show the Redsys interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPayIn Redsys PayIn Request Object params
     */
    payInsRedsysRedsysPostPaymentByWeb(params: {  "redsysPayIn"?: RedsysPayByWebPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsRedsys/payments/web`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redsysPayIn"]) {
            fetchOptions.body = JSON.stringify(params["redsysPayIn"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Redsys Preauthorization Request
     * Prepares a preauthorization on Redsys. The data returned is used to show the Redsys interface to the user.  Once the preauthoriation is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPreauthorization RedsysPreauthorization Object params
     */
    payInsRedsysRedsysPostPreauthorizationByWeb(params: {  "redsysPreauthorization"?: RedsysPreauthorizeByWebPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsRedsys/preauthorizations/web`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redsysPreauthorization"]) {
            fetchOptions.body = JSON.stringify(params["redsysPreauthorization"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Cancels a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationCancellation
     * @param redsysPreauthorizationCancellation PreauthorizationCancellation Object params
     */
    payInsRedsysRedsysPostPreauthorizationCancellation(params: {  "preauthorizationId": number; "redsysPreauthorizationCancellation"?: RedsysPreauthorizationCancellationPost; }, options?: any): FetchArgs {
        // verify required parameter "preauthorizationId" is set
        if (params["preauthorizationId"] == null) {
            throw new Error("Missing required parameter preauthorizationId when calling payInsRedsysRedsysPostPreauthorizationCancellation");
        }
        const baseUrl = `/v2.01/PayInsRedsys/preauthorizations/{PreauthorizationId}/cancellation`
            .replace(`{${"PreauthorizationId"}}`, `${ params["preauthorizationId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redsysPreauthorizationCancellation"]) {
            fetchOptions.body = JSON.stringify(params["redsysPreauthorizationCancellation"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Confirms a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationConfirmation
     * @param redsysPreauthorizationConfirmation PreauthorizationConfirmation Object params
     */
    payInsRedsysRedsysPostPreauthorizationConfirmation(params: {  "preauthorizationId": number; "redsysPreauthorizationConfirmation"?: RedsysPreauthorizationConfirmationPost; }, options?: any): FetchArgs {
        // verify required parameter "preauthorizationId" is set
        if (params["preauthorizationId"] == null) {
            throw new Error("Missing required parameter preauthorizationId when calling payInsRedsysRedsysPostPreauthorizationConfirmation");
        }
        const baseUrl = `/v2.01/PayInsRedsys/preauthorizations/{PreauthorizationId}/confirmation`
            .replace(`{${"PreauthorizationId"}}`, `${ params["preauthorizationId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redsysPreauthorizationConfirmation"]) {
            fetchOptions.body = JSON.stringify(params["redsysPreauthorizationConfirmation"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Redsys Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param redsysRefund Refund Object params
     */
    payInsRedsysRedsysPostRefund(params: {  "payInId": number; "redsysRefund"?: RedsysRefundPost; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsRedsysRedsysPostRefund");
        }
        const baseUrl = `/v2.01/PayInsRedsys/payments/{PayInId}/refunds`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redsysRefund"]) {
            fetchOptions.body = JSON.stringify(params["redsysRefund"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayInsRedsysApi - functional programming interface
 */
export const PayInsRedsysApiFp = {
    /** 
     * View a Redsys payment
     * 
     * @param payInId The Id of a payment
     */
    payInsRedsysRedsysGetPayment(params: { "payInId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPayInsResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysGetPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * View a Redsys Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys Preauthorization
     */
    payInsRedsysRedsysGetPreauthorization(params: { "preauthorizationId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPreauthorizeResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysGetPreauthorization(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Redsys PayIn Request
     * Prepares a payment on Redsys. The data returned is used to show the Redsys interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPayIn Redsys PayIn Request Object params
     */
    payInsRedsysRedsysPostPaymentByWeb(params: { "redsysPayIn"?: RedsysPayByWebPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPayByWebResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysPostPaymentByWeb(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Redsys Preauthorization Request
     * Prepares a preauthorization on Redsys. The data returned is used to show the Redsys interface to the user.  Once the preauthoriation is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPreauthorization RedsysPreauthorization Object params
     */
    payInsRedsysRedsysPostPreauthorizationByWeb(params: { "redsysPreauthorization"?: RedsysPreauthorizeByWebPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPreauthorizeByWebResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysPostPreauthorizationByWeb(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Cancels a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationCancellation
     * @param redsysPreauthorizationCancellation PreauthorizationCancellation Object params
     */
    payInsRedsysRedsysPostPreauthorizationCancellation(params: { "preauthorizationId": number; "redsysPreauthorizationCancellation"?: RedsysPreauthorizationCancellationPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPreauthorizationCancellationResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysPostPreauthorizationCancellation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Confirms a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationConfirmation
     * @param redsysPreauthorizationConfirmation PreauthorizationConfirmation Object params
     */
    payInsRedsysRedsysPostPreauthorizationConfirmation(params: { "preauthorizationId": number; "redsysPreauthorizationConfirmation"?: RedsysPreauthorizationConfirmationPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysPreauthorizationConfirmationResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysPostPreauthorizationConfirmation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Redsys Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param redsysRefund Refund Object params
     */
    payInsRedsysRedsysPostRefund(params: { "payInId": number; "redsysRefund"?: RedsysRefundPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedsysRefundResponse> {
        const fetchArgs = PayInsRedsysApiFetchParamCreator.payInsRedsysRedsysPostRefund(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayInsRedsysApi - object-oriented interface
 */
export class PayInsRedsysApi extends BaseAPI {
    /** 
     * View a Redsys payment
     * 
     * @param payInId The Id of a payment
     */
    payInsRedsysRedsysGetPayment(params: {  "payInId": number; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysGetPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * View a Redsys Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys Preauthorization
     */
    payInsRedsysRedsysGetPreauthorization(params: {  "preauthorizationId": number; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysGetPreauthorization(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Redsys PayIn Request
     * Prepares a payment on Redsys. The data returned is used to show the Redsys interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPayIn Redsys PayIn Request Object params
     */
    payInsRedsysRedsysPostPaymentByWeb(params: {  "redsysPayIn"?: RedsysPayByWebPost; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysPostPaymentByWeb(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Redsys Preauthorization Request
     * Prepares a preauthorization on Redsys. The data returned is used to show the Redsys interface to the user.  Once the preauthoriation is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param redsysPreauthorization RedsysPreauthorization Object params
     */
    payInsRedsysRedsysPostPreauthorizationByWeb(params: {  "redsysPreauthorization"?: RedsysPreauthorizeByWebPost; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationByWeb(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Cancels a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationCancellation
     * @param redsysPreauthorizationCancellation PreauthorizationCancellation Object params
     */
    payInsRedsysRedsysPostPreauthorizationCancellation(params: {  "preauthorizationId": number; "redsysPreauthorizationCancellation"?: RedsysPreauthorizationCancellationPost; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationCancellation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Confirms a Preauthorization
     * 
     * @param preauthorizationId The Id of a Redsys PreauthorizationConfirmation
     * @param redsysPreauthorizationConfirmation PreauthorizationConfirmation Object params
     */
    payInsRedsysRedsysPostPreauthorizationConfirmation(params: {  "preauthorizationId": number; "redsysPreauthorizationConfirmation"?: RedsysPreauthorizationConfirmationPost; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationConfirmation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Redsys Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param redsysRefund Refund Object params
     */
    payInsRedsysRedsysPostRefund(params: {  "payInId": number; "redsysRefund"?: RedsysRefundPost; }, options?: any) {
        return PayInsRedsysApiFp.payInsRedsysRedsysPostRefund(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayInsRedsysApi - factory interface
 */
export const PayInsRedsysApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a Redsys payment
         * 
         * @param payInId The Id of a payment
         */
        payInsRedsysRedsysGetPayment(params: {  "payInId": number; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysGetPayment(params, options)(fetch, basePath);
        },
        /** 
         * View a Redsys Preauthorization
         * 
         * @param preauthorizationId The Id of a Redsys Preauthorization
         */
        payInsRedsysRedsysGetPreauthorization(params: {  "preauthorizationId": number; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysGetPreauthorization(params, options)(fetch, basePath);
        },
        /** 
         * Create a Redsys PayIn Request
         * Prepares a payment on Redsys. The data returned is used to show the Redsys interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
         * @param redsysPayIn Redsys PayIn Request Object params
         */
        payInsRedsysRedsysPostPaymentByWeb(params: {  "redsysPayIn"?: RedsysPayByWebPost; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysPostPaymentByWeb(params, options)(fetch, basePath);
        },
        /** 
         * Create a Redsys Preauthorization Request
         * Prepares a preauthorization on Redsys. The data returned is used to show the Redsys interface to the user.  Once the preauthoriation is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
         * @param redsysPreauthorization RedsysPreauthorization Object params
         */
        payInsRedsysRedsysPostPreauthorizationByWeb(params: {  "redsysPreauthorization"?: RedsysPreauthorizeByWebPost; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationByWeb(params, options)(fetch, basePath);
        },
        /** 
         * Cancels a Preauthorization
         * 
         * @param preauthorizationId The Id of a Redsys PreauthorizationCancellation
         * @param redsysPreauthorizationCancellation PreauthorizationCancellation Object params
         */
        payInsRedsysRedsysPostPreauthorizationCancellation(params: {  "preauthorizationId": number; "redsysPreauthorizationCancellation"?: RedsysPreauthorizationCancellationPost; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationCancellation(params, options)(fetch, basePath);
        },
        /** 
         * Confirms a Preauthorization
         * 
         * @param preauthorizationId The Id of a Redsys PreauthorizationConfirmation
         * @param redsysPreauthorizationConfirmation PreauthorizationConfirmation Object params
         */
        payInsRedsysRedsysPostPreauthorizationConfirmation(params: {  "preauthorizationId": number; "redsysPreauthorizationConfirmation"?: RedsysPreauthorizationConfirmationPost; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysPostPreauthorizationConfirmation(params, options)(fetch, basePath);
        },
        /** 
         * Create a Redsys Payment Refund
         * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
         * @param payInId The Id of a PayIn
         * @param redsysRefund Refund Object params
         */
        payInsRedsysRedsysPostRefund(params: {  "payInId": number; "redsysRefund"?: RedsysRefundPost; }, options?: any) {
            return PayInsRedsysApiFp.payInsRedsysRedsysPostRefund(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayInsUniversalPayApi - fetch parameter creator
 */
export const PayInsUniversalPayApiFetchParamCreator = {
    /** 
     * @param tokenId 
     */
    payInsUniversalPayGetUniversalPayTokenization(params: {  "tokenId": number; }, options?: any): FetchArgs {
        // verify required parameter "tokenId" is set
        if (params["tokenId"] == null) {
            throw new Error("Missing required parameter tokenId when calling payInsUniversalPayGetUniversalPayTokenization");
        }
        const baseUrl = `/v2.01/PayInsUniversalPay/token/{TokenId}`
            .replace(`{${"TokenId"}}`, `${ params["tokenId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * View a UniversalPay payment
     * 
     * @param payInId The Id of a payment
     */
    payInsUniversalPayUniversalPayGetPayment(params: {  "payInId": number; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsUniversalPayUniversalPayGetPayment");
        }
        const baseUrl = `/v2.01/PayInsUniversalPay/payments/{PayInId}`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a UniversalPay PayIn Request
     * Prepares a payment on UniversalPay. The data returned is used to show the UniversalPay interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param universalPayPayIn UniversalPay PayIn Request Object params
     */
    payInsUniversalPayUniversalPayPostPaymentByWeb(params: {  "universalPayPayIn"?: UniversalPayPayByWebPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsUniversalPay/payments/web`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["universalPayPayIn"]) {
            fetchOptions.body = JSON.stringify(params["universalPayPayIn"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a UniversalPay Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param universalPayRefund Refund Object params
     */
    payInsUniversalPayUniversalPayPostRefund(params: {  "payInId": number; "universalPayRefund"?: UniversalPayRefundPost; }, options?: any): FetchArgs {
        // verify required parameter "payInId" is set
        if (params["payInId"] == null) {
            throw new Error("Missing required parameter payInId when calling payInsUniversalPayUniversalPayPostRefund");
        }
        const baseUrl = `/v2.01/PayInsUniversalPay/payments/{PayInId}/refunds`
            .replace(`{${"PayInId"}}`, `${ params["payInId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["universalPayRefund"]) {
            fetchOptions.body = JSON.stringify(params["universalPayRefund"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param universalPaySaveCard 
     */
    payInsUniversalPayUniversalPaySaveCard(params: {  "universalPaySaveCard"?: UniversalPayTokenRequestPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayInsUniversalPay/token/web`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["universalPaySaveCard"]) {
            fetchOptions.body = JSON.stringify(params["universalPaySaveCard"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayInsUniversalPayApi - functional programming interface
 */
export const PayInsUniversalPayApiFp = {
    /** 
     * @param tokenId 
     */
    payInsUniversalPayGetUniversalPayTokenization(params: { "tokenId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayTokenizationResponse> {
        const fetchArgs = PayInsUniversalPayApiFetchParamCreator.payInsUniversalPayGetUniversalPayTokenization(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * View a UniversalPay payment
     * 
     * @param payInId The Id of a payment
     */
    payInsUniversalPayUniversalPayGetPayment(params: { "payInId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayPayInsResponse> {
        const fetchArgs = PayInsUniversalPayApiFetchParamCreator.payInsUniversalPayUniversalPayGetPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a UniversalPay PayIn Request
     * Prepares a payment on UniversalPay. The data returned is used to show the UniversalPay interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param universalPayPayIn UniversalPay PayIn Request Object params
     */
    payInsUniversalPayUniversalPayPostPaymentByWeb(params: { "universalPayPayIn"?: UniversalPayPayByWebPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayPayByWebResponse> {
        const fetchArgs = PayInsUniversalPayApiFetchParamCreator.payInsUniversalPayUniversalPayPostPaymentByWeb(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a UniversalPay Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param universalPayRefund Refund Object params
     */
    payInsUniversalPayUniversalPayPostRefund(params: { "payInId": number; "universalPayRefund"?: UniversalPayRefundPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayRefundResponse> {
        const fetchArgs = PayInsUniversalPayApiFetchParamCreator.payInsUniversalPayUniversalPayPostRefund(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param universalPaySaveCard 
     */
    payInsUniversalPayUniversalPaySaveCard(params: { "universalPaySaveCard"?: UniversalPayTokenRequestPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayTokenizeByWebResponse> {
        const fetchArgs = PayInsUniversalPayApiFetchParamCreator.payInsUniversalPayUniversalPaySaveCard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayInsUniversalPayApi - object-oriented interface
 */
export class PayInsUniversalPayApi extends BaseAPI {
    /** 
     * @param tokenId 
     */
    payInsUniversalPayGetUniversalPayTokenization(params: {  "tokenId": number; }, options?: any) {
        return PayInsUniversalPayApiFp.payInsUniversalPayGetUniversalPayTokenization(params, options)(this.fetch, this.basePath);
    }
    /** 
     * View a UniversalPay payment
     * 
     * @param payInId The Id of a payment
     */
    payInsUniversalPayUniversalPayGetPayment(params: {  "payInId": number; }, options?: any) {
        return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayGetPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a UniversalPay PayIn Request
     * Prepares a payment on UniversalPay. The data returned is used to show the UniversalPay interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
     * @param universalPayPayIn UniversalPay PayIn Request Object params
     */
    payInsUniversalPayUniversalPayPostPaymentByWeb(params: {  "universalPayPayIn"?: UniversalPayPayByWebPost; }, options?: any) {
        return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayPostPaymentByWeb(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a UniversalPay Payment Refund
     * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
     * @param payInId The Id of a PayIn
     * @param universalPayRefund Refund Object params
     */
    payInsUniversalPayUniversalPayPostRefund(params: {  "payInId": number; "universalPayRefund"?: UniversalPayRefundPost; }, options?: any) {
        return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayPostRefund(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param universalPaySaveCard 
     */
    payInsUniversalPayUniversalPaySaveCard(params: {  "universalPaySaveCard"?: UniversalPayTokenRequestPost; }, options?: any) {
        return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPaySaveCard(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayInsUniversalPayApi - factory interface
 */
export const PayInsUniversalPayApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param tokenId 
         */
        payInsUniversalPayGetUniversalPayTokenization(params: {  "tokenId": number; }, options?: any) {
            return PayInsUniversalPayApiFp.payInsUniversalPayGetUniversalPayTokenization(params, options)(fetch, basePath);
        },
        /** 
         * View a UniversalPay payment
         * 
         * @param payInId The Id of a payment
         */
        payInsUniversalPayUniversalPayGetPayment(params: {  "payInId": number; }, options?: any) {
            return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayGetPayment(params, options)(fetch, basePath);
        },
        /** 
         * Create a UniversalPay PayIn Request
         * Prepares a payment on UniversalPay. The data returned is used to show the UniversalPay interface to the user.  Once the payment is done, the user will be redirected to one of UrlOk or UrlKo passed parameters.  In order to redirect the user, a Post request with Content-Type of application/x-www-form-urlencoded must be executed from the user&#39;s browser.  Below there is an example of a request where the params surrounded by curly braces have to be replaced with the response&#39;s params.  curl -X POST -H \&quot;Content-Type: application/x-www-form-urlencoded\&quot; -H \&quot;Accept: text/html,application/xhtml+xml,application/xml;q&#x3D;0.9,image/webp,*_/_*;q&#x3D;0.8\&quot; -H \&quot;Cache-Control: no-cache\&quot; -H \&quot;Postman-Token: c313f10b-0de1-227e-53d2-f721f25cd79d\&quot; -d &#39;Ds_SignatureVersion&#x3D;{Ds_SignatureVersion}&amp;amp;Ds_MerchantParameters&#x3D;{Ds_MerchantParameters}&amp;amp;Ds_Signature&#x3D;{Ds_Signature}&#39; \&quot;{Url}\&quot;
         * @param universalPayPayIn UniversalPay PayIn Request Object params
         */
        payInsUniversalPayUniversalPayPostPaymentByWeb(params: {  "universalPayPayIn"?: UniversalPayPayByWebPost; }, options?: any) {
            return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayPostPaymentByWeb(params, options)(fetch, basePath);
        },
        /** 
         * Create a UniversalPay Payment Refund
         * A PayIn Refund is a request to reimburse a user on their payment card. The money which has already been paid will automatically go back to the user’s bank account.              Minimum amount to refund is 1€.              If you&#39;re doing a partial Refund, note that you can only refund the same amount on the same transaction once per day (this is to prevent unintended duplicate refunds). After 24h you can do another refund of the same amount on the same transaction. If it is a different amount on the same transaction, there is not this limit.              If you do not specify DebitedFunds and Fees parameters, it will automatically fully refund the PayIn. However if you do provide one or the other, you must provide both. Note that Fees must be negative if you wish to refund them - adding a positive value for the Fees is a way to charge your customers for the Refund (in the same way you might for a PayIn, Transfer or any other Transaction
         * @param payInId The Id of a PayIn
         * @param universalPayRefund Refund Object params
         */
        payInsUniversalPayUniversalPayPostRefund(params: {  "payInId": number; "universalPayRefund"?: UniversalPayRefundPost; }, options?: any) {
            return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPayPostRefund(params, options)(fetch, basePath);
        },
        /** 
         * @param universalPaySaveCard 
         */
        payInsUniversalPayUniversalPaySaveCard(params: {  "universalPaySaveCard"?: UniversalPayTokenRequestPost; }, options?: any) {
            return PayInsUniversalPayApiFp.payInsUniversalPayUniversalPaySaveCard(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayOutsApi - fetch parameter creator
 */
export const PayOutsApiFetchParamCreator = {
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param id SwaggerDocParameter
     */
    payOutsGet(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payOutsGet");
        }
        const baseUrl = `/v2.01/PayOuts/bankwire/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param request SwaggerDocParameter
     */
    payOutsPost(params: {  "request"?: PayOutBankWirePost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/PayOuts/bankwire`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayOutsApi - functional programming interface
 */
export const PayOutsApiFp = {
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param id SwaggerDocParameter
     */
    payOutsGet(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayOutBankWireResponse> {
        const fetchArgs = PayOutsApiFetchParamCreator.payOutsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param request SwaggerDocParameter
     */
    payOutsPost(params: { "request"?: PayOutBankWirePost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayOutBankWireResponse> {
        const fetchArgs = PayOutsApiFetchParamCreator.payOutsPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayOutsApi - object-oriented interface
 */
export class PayOutsApi extends BaseAPI {
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param id SwaggerDocParameter
     */
    payOutsGet(params: {  "id": number; }, options?: any) {
        return PayOutsApiFp.payOutsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * SwaggerDocSummary
     * SwaggerDocDescription
     * @param request SwaggerDocParameter
     */
    payOutsPost(params: {  "request"?: PayOutBankWirePost; }, options?: any) {
        return PayOutsApiFp.payOutsPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayOutsApi - factory interface
 */
export const PayOutsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * SwaggerDocSummary
         * SwaggerDocDescription
         * @param id SwaggerDocParameter
         */
        payOutsGet(params: {  "id": number; }, options?: any) {
            return PayOutsApiFp.payOutsGet(params, options)(fetch, basePath);
        },
        /** 
         * SwaggerDocSummary
         * SwaggerDocDescription
         * @param request SwaggerDocParameter
         */
        payOutsPost(params: {  "request"?: PayOutBankWirePost; }, options?: any) {
            return PayOutsApiFp.payOutsPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * RefundsApi - fetch parameter creator
 */
export const RefundsApiFetchParamCreator = {
    /** 
     * View a Refund
     * No matter if it is              a PayIn refund : request to reimburse a user on its payment card. The money which has already been paid will automatically go back to the user’s bank account              a Transfer : request to reimburse a wallet. The money which comes from a wallet and has already been transferred to another one goes back to the wallet it came from              or a PayOut refund              Note that PayOut refunds can only be generated by MarketPay. The Id is obtained through the event or the hook notification PAYOUT_REFUND_SUCCEEDED
     * @param refundId The ID of a refund
     */
    refundsRefundGet(params: {  "refundId": number; }, options?: any): FetchArgs {
        // verify required parameter "refundId" is set
        if (params["refundId"] == null) {
            throw new Error("Missing required parameter refundId when calling refundsRefundGet");
        }
        const baseUrl = `/v2.01/Refunds/{RefundId}`
            .replace(`{${"RefundId"}}`, `${ params["refundId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RefundsApi - functional programming interface
 */
export const RefundsApiFp = {
    /** 
     * View a Refund
     * No matter if it is              a PayIn refund : request to reimburse a user on its payment card. The money which has already been paid will automatically go back to the user’s bank account              a Transfer : request to reimburse a wallet. The money which comes from a wallet and has already been transferred to another one goes back to the wallet it came from              or a PayOut refund              Note that PayOut refunds can only be generated by MarketPay. The Id is obtained through the event or the hook notification PAYOUT_REFUND_SUCCEEDED
     * @param refundId The ID of a refund
     */
    refundsRefundGet(params: { "refundId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UniversalPayRefundResponse> {
        const fetchArgs = RefundsApiFetchParamCreator.refundsRefundGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RefundsApi - object-oriented interface
 */
export class RefundsApi extends BaseAPI {
    /** 
     * View a Refund
     * No matter if it is              a PayIn refund : request to reimburse a user on its payment card. The money which has already been paid will automatically go back to the user’s bank account              a Transfer : request to reimburse a wallet. The money which comes from a wallet and has already been transferred to another one goes back to the wallet it came from              or a PayOut refund              Note that PayOut refunds can only be generated by MarketPay. The Id is obtained through the event or the hook notification PAYOUT_REFUND_SUCCEEDED
     * @param refundId The ID of a refund
     */
    refundsRefundGet(params: {  "refundId": number; }, options?: any) {
        return RefundsApiFp.refundsRefundGet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RefundsApi - factory interface
 */
export const RefundsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a Refund
         * No matter if it is              a PayIn refund : request to reimburse a user on its payment card. The money which has already been paid will automatically go back to the user’s bank account              a Transfer : request to reimburse a wallet. The money which comes from a wallet and has already been transferred to another one goes back to the wallet it came from              or a PayOut refund              Note that PayOut refunds can only be generated by MarketPay. The Id is obtained through the event or the hook notification PAYOUT_REFUND_SUCCEEDED
         * @param refundId The ID of a refund
         */
        refundsRefundGet(params: {  "refundId": number; }, options?: any) {
            return RefundsApiFp.refundsRefundGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * ShipmentSeurApi - fetch parameter creator
 */
export const ShipmentSeurApiFetchParamCreator = {
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurCancelShipment(params: {  "shipmentId": number; }, options?: any): FetchArgs {
        // verify required parameter "shipmentId" is set
        if (params["shipmentId"] == null) {
            throw new Error("Missing required parameter shipmentId when calling shipmentSeurSeurCancelShipment");
        }
        const baseUrl = `/v2.01/ShipmentSeur/shipments/{ShipmentId}/cancellation`
            .replace(`{${"ShipmentId"}}`, `${ params["shipmentId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Creates a shipment
     * Creates a shipment
     * @param shipment Seur Shipment Object params
     */
    shipmentSeurSeurCreateShipment(params: {  "shipment"?: SeurShipmentPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/ShipmentSeur/shipments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shipment"]) {
            fetchOptions.body = JSON.stringify(params["shipment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurGetShipment(params: {  "shipmentId": number; }, options?: any): FetchArgs {
        // verify required parameter "shipmentId" is set
        if (params["shipmentId"] == null) {
            throw new Error("Missing required parameter shipmentId when calling shipmentSeurSeurGetShipment");
        }
        const baseUrl = `/v2.01/ShipmentSeur/shipments/{ShipmentId}`
            .replace(`{${"ShipmentId"}}`, `${ params["shipmentId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ShipmentSeurApi - functional programming interface
 */
export const ShipmentSeurApiFp = {
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurCancelShipment(params: { "shipmentId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeurShipmentCancellationResponse> {
        const fetchArgs = ShipmentSeurApiFetchParamCreator.shipmentSeurSeurCancelShipment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Creates a shipment
     * Creates a shipment
     * @param shipment Seur Shipment Object params
     */
    shipmentSeurSeurCreateShipment(params: { "shipment"?: SeurShipmentPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeurShipmentResponse> {
        const fetchArgs = ShipmentSeurApiFetchParamCreator.shipmentSeurSeurCreateShipment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurGetShipment(params: { "shipmentId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SeurShipmentResponse> {
        const fetchArgs = ShipmentSeurApiFetchParamCreator.shipmentSeurSeurGetShipment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ShipmentSeurApi - object-oriented interface
 */
export class ShipmentSeurApi extends BaseAPI {
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurCancelShipment(params: {  "shipmentId": number; }, options?: any) {
        return ShipmentSeurApiFp.shipmentSeurSeurCancelShipment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Creates a shipment
     * Creates a shipment
     * @param shipment Seur Shipment Object params
     */
    shipmentSeurSeurCreateShipment(params: {  "shipment"?: SeurShipmentPost; }, options?: any) {
        return ShipmentSeurApiFp.shipmentSeurSeurCreateShipment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Cancels a shipment
     * Cancels a shipment
     * @param shipmentId The Id of a Shipment
     */
    shipmentSeurSeurGetShipment(params: {  "shipmentId": number; }, options?: any) {
        return ShipmentSeurApiFp.shipmentSeurSeurGetShipment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ShipmentSeurApi - factory interface
 */
export const ShipmentSeurApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Cancels a shipment
         * Cancels a shipment
         * @param shipmentId The Id of a Shipment
         */
        shipmentSeurSeurCancelShipment(params: {  "shipmentId": number; }, options?: any) {
            return ShipmentSeurApiFp.shipmentSeurSeurCancelShipment(params, options)(fetch, basePath);
        },
        /** 
         * Creates a shipment
         * Creates a shipment
         * @param shipment Seur Shipment Object params
         */
        shipmentSeurSeurCreateShipment(params: {  "shipment"?: SeurShipmentPost; }, options?: any) {
            return ShipmentSeurApiFp.shipmentSeurSeurCreateShipment(params, options)(fetch, basePath);
        },
        /** 
         * Cancels a shipment
         * Cancels a shipment
         * @param shipmentId The Id of a Shipment
         */
        shipmentSeurSeurGetShipment(params: {  "shipmentId": number; }, options?: any) {
            return ShipmentSeurApiFp.shipmentSeurSeurGetShipment(params, options)(fetch, basePath);
        },
    };
};


/**
 * TransactionsApi - fetch parameter creator
 */
export const TransactionsApiFetchParamCreator = {
    /** 
     * @param page 
     * @param perPage 
     */
    transactionsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = {
    /** 
     * @param page 
     * @param perPage 
     */
    transactionsGetList(params: { "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseListTransactionResponse> {
        const fetchArgs = TransactionsApiFetchParamCreator.transactionsGetList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI {
    /** 
     * @param page 
     * @param perPage 
     */
    transactionsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
        return TransactionsApiFp.transactionsGetList(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param page 
         * @param perPage 
         */
        transactionsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
            return TransactionsApiFp.transactionsGetList(params, options)(fetch, basePath);
        },
    };
};


/**
 * TransfersApi - fetch parameter creator
 */
export const TransfersApiFetchParamCreator = {
    /** 
     * View a Transfer
     * A Transfer is a request to relocate e-money from one wallet to another wallet.
     * @param transferId The Id of a transfer
     */
    transfersGet(params: {  "transferId": number; }, options?: any): FetchArgs {
        // verify required parameter "transferId" is set
        if (params["transferId"] == null) {
            throw new Error("Missing required parameter transferId when calling transfersGet");
        }
        const baseUrl = `/v2.01/Transfers/{TransferId}`
            .replace(`{${"TransferId"}}`, `${ params["transferId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    transfersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Transfers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Transfer
     * 
     * @param transfer Transfer Object params
     */
    transfersPost(params: {  "transfer"?: TransferPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Transfers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["transfer"]) {
            fetchOptions.body = JSON.stringify(params["transfer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TransfersApi - functional programming interface
 */
export const TransfersApiFp = {
    /** 
     * View a Transfer
     * A Transfer is a request to relocate e-money from one wallet to another wallet.
     * @param transferId The Id of a transfer
     */
    transfersGet(params: { "transferId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferResponse> {
        const fetchArgs = TransfersApiFetchParamCreator.transfersGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    transfersGetList(params: { "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseListTransferResponse> {
        const fetchArgs = TransfersApiFetchParamCreator.transfersGetList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Transfer
     * 
     * @param transfer Transfer Object params
     */
    transfersPost(params: { "transfer"?: TransferPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferResponse> {
        const fetchArgs = TransfersApiFetchParamCreator.transfersPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TransfersApi - object-oriented interface
 */
export class TransfersApi extends BaseAPI {
    /** 
     * View a Transfer
     * A Transfer is a request to relocate e-money from one wallet to another wallet.
     * @param transferId The Id of a transfer
     */
    transfersGet(params: {  "transferId": number; }, options?: any) {
        return TransfersApiFp.transfersGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param page 
     * @param perPage 
     */
    transfersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
        return TransfersApiFp.transfersGetList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Transfer
     * 
     * @param transfer Transfer Object params
     */
    transfersPost(params: {  "transfer"?: TransferPost; }, options?: any) {
        return TransfersApiFp.transfersPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TransfersApi - factory interface
 */
export const TransfersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a Transfer
         * A Transfer is a request to relocate e-money from one wallet to another wallet.
         * @param transferId The Id of a transfer
         */
        transfersGet(params: {  "transferId": number; }, options?: any) {
            return TransfersApiFp.transfersGet(params, options)(fetch, basePath);
        },
        /** 
         * @param page 
         * @param perPage 
         */
        transfersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
            return TransfersApiFp.transfersGetList(params, options)(fetch, basePath);
        },
        /** 
         * Create a Transfer
         * 
         * @param transfer Transfer Object params
         */
        transfersPost(params: {  "transfer"?: TransferPost; }, options?: any) {
            return TransfersApiFp.transfersPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersApi - fetch parameter creator
 */
export const UsersApiFetchParamCreator = {
    /** 
     * View a User
     * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
     * @param userId The Id of a user
     */
    usersGet(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGet");
        }
        const baseUrl = `/v2.01/Users/{UserId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * View a Bank Account
     * 
     * @param userId The Id of a user
     * @param bankAccountId The Id of a bank account
     */
    usersGetBankAccount(params: {  "userId": number; "bankAccountId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetBankAccount");
        }
        // verify required parameter "bankAccountId" is set
        if (params["bankAccountId"] == null) {
            throw new Error("Missing required parameter bankAccountId when calling usersGetBankAccount");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/{BankAccountId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`)
            .replace(`{${"BankAccountId"}}`, `${ params["bankAccountId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List Bank Accounts for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetBankAccountList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetBankAccountList");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List Cards for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetCardList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetCardList");
        }
        const baseUrl = `/v2.01/Users/{UserId}/cards`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * View a Legal User
     * 
     * @param userId The Id of a legal user
     */
    usersGetLegal(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetLegal");
        }
        const baseUrl = `/v2.01/Users/legal/{UserId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List all Users
     * 
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * View a Natural User
     * 
     * @param userId The Id of a natural user
     */
    usersGetNatural(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetNatural");
        }
        const baseUrl = `/v2.01/Users/natural/{UserId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List Transactions for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetTransactionList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetTransactionList");
        }
        const baseUrl = `/v2.01/Users/{UserId}/transactions`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List Wallets for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetWalletList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersGetWalletList");
        }
        const baseUrl = `/v2.01/Users/{UserId}/wallets`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a CA BankAccount
     * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
     * @param userId The Id of a user
     * @param bankAccountCA BankAccountCA Object params
     */
    usersPostBankAccountCa(params: {  "userId": number; "bankAccountCA"?: BankAccountCaPost; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPostBankAccountCa");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/CA`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankAccountCA"]) {
            fetchOptions.body = JSON.stringify(params["bankAccountCA"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a GB BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountGB 
     */
    usersPostBankAccountGb(params: {  "userId": number; "bankAccountGB"?: BankAccountGbPost; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPostBankAccountGb");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/GB`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankAccountGB"]) {
            fetchOptions.body = JSON.stringify(params["bankAccountGB"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an IBAN BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountIBAN BankAccountIBAN Object params
     */
    usersPostBankAccountIban(params: {  "userId": number; "bankAccountIBAN"?: BankAccountIbanPost; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPostBankAccountIban");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/IBAN`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankAccountIBAN"]) {
            fetchOptions.body = JSON.stringify(params["bankAccountIBAN"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an OTHER BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountOTHER 
     */
    usersPostBankAccountOther(params: {  "userId": number; "bankAccountOTHER"?: BankAccountOtherPost; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPostBankAccountOther");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/OTHER`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankAccountOTHER"]) {
            fetchOptions.body = JSON.stringify(params["bankAccountOTHER"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an US BankAccount
     * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
     * @param userId The Id of a user
     * @param bankAccountUS BankAccountUS Object params
     */
    usersPostBankAccountUs(params: {  "userId": number; "bankAccountUS"?: BankAccountUsPost; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPostBankAccountUs");
        }
        const baseUrl = `/v2.01/Users/{UserId}/bankaccounts/US`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bankAccountUS"]) {
            fetchOptions.body = JSON.stringify(params["bankAccountUS"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userLegal UserLegal Object params
     */
    usersPostLegal(params: {  "userLegal"?: UserLegalPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Users/legal`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userLegal"]) {
            fetchOptions.body = JSON.stringify(params["userLegal"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userNatural UserNatural Object params
     */
    usersPostNatural(params: {  "userNatural"?: UserNaturalPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Users/natural`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userNatural"]) {
            fetchOptions.body = JSON.stringify(params["userNatural"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userLegal UserLegal Object params
     */
    usersPutLegal(params: {  "userId": number; "userLegal"?: UserLegalPut; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPutLegal");
        }
        const baseUrl = `/v2.01/Users/legal/{UserId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userLegal"]) {
            fetchOptions.body = JSON.stringify(params["userLegal"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userNatural UserNatural Object params
     */
    usersPutNatural(params: {  "userId": number; "userNatural"?: UserNaturalPut; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling usersPutNatural");
        }
        const baseUrl = `/v2.01/Users/natural/{UserId}`
            .replace(`{${"UserId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userNatural"]) {
            fetchOptions.body = JSON.stringify(params["userNatural"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = {
    /** 
     * View a User
     * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
     * @param userId The Id of a user
     */
    usersGet(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * View a Bank Account
     * 
     * @param userId The Id of a user
     * @param bankAccountId The Id of a bank account
     */
    usersGetBankAccount(params: { "userId": number; "bankAccountId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetBankAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List Bank Accounts for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetBankAccountList(params: { "userId": number; "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BankAccountResponse>> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetBankAccountList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List Cards for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetCardList(params: { "userId": number; "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CardResponse>> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetCardList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * View a Legal User
     * 
     * @param userId The Id of a legal user
     */
    usersGetLegal(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLegalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetLegal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List all Users
     * 
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetList(params: { "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserResponse>> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * View a Natural User
     * 
     * @param userId The Id of a natural user
     */
    usersGetNatural(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNaturalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetNatural(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List Transactions for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetTransactionList(params: { "userId": number; "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TransactionResponse>> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetTransactionList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List Wallets for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetWalletList(params: { "userId": number; "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WalletResponse>> {
        const fetchArgs = UsersApiFetchParamCreator.usersGetWalletList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a CA BankAccount
     * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
     * @param userId The Id of a user
     * @param bankAccountCA BankAccountCA Object params
     */
    usersPostBankAccountCa(params: { "userId": number; "bankAccountCA"?: BankAccountCaPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponseCa> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostBankAccountCa(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a GB BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountGB 
     */
    usersPostBankAccountGb(params: { "userId": number; "bankAccountGB"?: BankAccountGbPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponseGb> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostBankAccountGb(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an IBAN BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountIBAN BankAccountIBAN Object params
     */
    usersPostBankAccountIban(params: { "userId": number; "bankAccountIBAN"?: BankAccountIbanPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponseIban> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostBankAccountIban(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an OTHER BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountOTHER 
     */
    usersPostBankAccountOther(params: { "userId": number; "bankAccountOTHER"?: BankAccountOtherPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponseOther> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostBankAccountOther(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an US BankAccount
     * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
     * @param userId The Id of a user
     * @param bankAccountUS BankAccountUS Object params
     */
    usersPostBankAccountUs(params: { "userId": number; "bankAccountUS"?: BankAccountUsPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankAccountResponseUs> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostBankAccountUs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userLegal UserLegal Object params
     */
    usersPostLegal(params: { "userLegal"?: UserLegalPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLegalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostLegal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userNatural UserNatural Object params
     */
    usersPostNatural(params: { "userNatural"?: UserNaturalPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNaturalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersPostNatural(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userLegal UserLegal Object params
     */
    usersPutLegal(params: { "userId": number; "userLegal"?: UserLegalPut;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLegalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersPutLegal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userNatural UserNatural Object params
     */
    usersPutNatural(params: { "userId": number; "userNatural"?: UserNaturalPut;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNaturalResponse> {
        const fetchArgs = UsersApiFetchParamCreator.usersPutNatural(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /** 
     * View a User
     * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
     * @param userId The Id of a user
     */
    usersGet(params: {  "userId": number; }, options?: any) {
        return UsersApiFp.usersGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * View a Bank Account
     * 
     * @param userId The Id of a user
     * @param bankAccountId The Id of a bank account
     */
    usersGetBankAccount(params: {  "userId": number; "bankAccountId": number; }, options?: any) {
        return UsersApiFp.usersGetBankAccount(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List Bank Accounts for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetBankAccountList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
        return UsersApiFp.usersGetBankAccountList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List Cards for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetCardList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
        return UsersApiFp.usersGetCardList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * View a Legal User
     * 
     * @param userId The Id of a legal user
     */
    usersGetLegal(params: {  "userId": number; }, options?: any) {
        return UsersApiFp.usersGetLegal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List all Users
     * 
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
        return UsersApiFp.usersGetList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * View a Natural User
     * 
     * @param userId The Id of a natural user
     */
    usersGetNatural(params: {  "userId": number; }, options?: any) {
        return UsersApiFp.usersGetNatural(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List Transactions for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetTransactionList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
        return UsersApiFp.usersGetTransactionList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List Wallets for a User
     * 
     * @param userId The Id of a user
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    usersGetWalletList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
        return UsersApiFp.usersGetWalletList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a CA BankAccount
     * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
     * @param userId The Id of a user
     * @param bankAccountCA BankAccountCA Object params
     */
    usersPostBankAccountCa(params: {  "userId": number; "bankAccountCA"?: BankAccountCaPost; }, options?: any) {
        return UsersApiFp.usersPostBankAccountCa(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a GB BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountGB 
     */
    usersPostBankAccountGb(params: {  "userId": number; "bankAccountGB"?: BankAccountGbPost; }, options?: any) {
        return UsersApiFp.usersPostBankAccountGb(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an IBAN BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountIBAN BankAccountIBAN Object params
     */
    usersPostBankAccountIban(params: {  "userId": number; "bankAccountIBAN"?: BankAccountIbanPost; }, options?: any) {
        return UsersApiFp.usersPostBankAccountIban(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an OTHER BankAccount
     * 
     * @param userId The Id of a user
     * @param bankAccountOTHER 
     */
    usersPostBankAccountOther(params: {  "userId": number; "bankAccountOTHER"?: BankAccountOtherPost; }, options?: any) {
        return UsersApiFp.usersPostBankAccountOther(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an US BankAccount
     * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
     * @param userId The Id of a user
     * @param bankAccountUS BankAccountUS Object params
     */
    usersPostBankAccountUs(params: {  "userId": number; "bankAccountUS"?: BankAccountUsPost; }, options?: any) {
        return UsersApiFp.usersPostBankAccountUs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userLegal UserLegal Object params
     */
    usersPostLegal(params: {  "userLegal"?: UserLegalPost; }, options?: any) {
        return UsersApiFp.usersPostLegal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userNatural UserNatural Object params
     */
    usersPostNatural(params: {  "userNatural"?: UserNaturalPost; }, options?: any) {
        return UsersApiFp.usersPostNatural(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a Legal User
     * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userLegal UserLegal Object params
     */
    usersPutLegal(params: {  "userId": number; "userLegal"?: UserLegalPut; }, options?: any) {
        return UsersApiFp.usersPutLegal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a Natural User
     * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
     * @param userId The Id of a user
     * @param userNatural UserNatural Object params
     */
    usersPutNatural(params: {  "userId": number; "userNatural"?: UserNaturalPut; }, options?: any) {
        return UsersApiFp.usersPutNatural(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a User
         * A User can be \&quot;Natural\&quot; or \&quot;Legal\&quot;. With a UserId, you are able to:              Fetch a user and get their details              List all the wallets of a user              Get all your users in a list
         * @param userId The Id of a user
         */
        usersGet(params: {  "userId": number; }, options?: any) {
            return UsersApiFp.usersGet(params, options)(fetch, basePath);
        },
        /** 
         * View a Bank Account
         * 
         * @param userId The Id of a user
         * @param bankAccountId The Id of a bank account
         */
        usersGetBankAccount(params: {  "userId": number; "bankAccountId": number; }, options?: any) {
            return UsersApiFp.usersGetBankAccount(params, options)(fetch, basePath);
        },
        /** 
         * List Bank Accounts for a User
         * 
         * @param userId The Id of a user
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        usersGetBankAccountList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
            return UsersApiFp.usersGetBankAccountList(params, options)(fetch, basePath);
        },
        /** 
         * List Cards for a User
         * 
         * @param userId The Id of a user
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        usersGetCardList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
            return UsersApiFp.usersGetCardList(params, options)(fetch, basePath);
        },
        /** 
         * View a Legal User
         * 
         * @param userId The Id of a legal user
         */
        usersGetLegal(params: {  "userId": number; }, options?: any) {
            return UsersApiFp.usersGetLegal(params, options)(fetch, basePath);
        },
        /** 
         * List all Users
         * 
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        usersGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
            return UsersApiFp.usersGetList(params, options)(fetch, basePath);
        },
        /** 
         * View a Natural User
         * 
         * @param userId The Id of a natural user
         */
        usersGetNatural(params: {  "userId": number; }, options?: any) {
            return UsersApiFp.usersGetNatural(params, options)(fetch, basePath);
        },
        /** 
         * List Transactions for a User
         * 
         * @param userId The Id of a user
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        usersGetTransactionList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
            return UsersApiFp.usersGetTransactionList(params, options)(fetch, basePath);
        },
        /** 
         * List Wallets for a User
         * 
         * @param userId The Id of a user
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        usersGetWalletList(params: {  "userId": number; "page"?: number; "perPage"?: number; }, options?: any) {
            return UsersApiFp.usersGetWalletList(params, options)(fetch, basePath);
        },
        /** 
         * Create a CA BankAccount
         * In the case of CAD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object
         * @param userId The Id of a user
         * @param bankAccountCA BankAccountCA Object params
         */
        usersPostBankAccountCa(params: {  "userId": number; "bankAccountCA"?: BankAccountCaPost; }, options?: any) {
            return UsersApiFp.usersPostBankAccountCa(params, options)(fetch, basePath);
        },
        /** 
         * Create a GB BankAccount
         * 
         * @param userId The Id of a user
         * @param bankAccountGB 
         */
        usersPostBankAccountGb(params: {  "userId": number; "bankAccountGB"?: BankAccountGbPost; }, options?: any) {
            return UsersApiFp.usersPostBankAccountGb(params, options)(fetch, basePath);
        },
        /** 
         * Create an IBAN BankAccount
         * 
         * @param userId The Id of a user
         * @param bankAccountIBAN BankAccountIBAN Object params
         */
        usersPostBankAccountIban(params: {  "userId": number; "bankAccountIBAN"?: BankAccountIbanPost; }, options?: any) {
            return UsersApiFp.usersPostBankAccountIban(params, options)(fetch, basePath);
        },
        /** 
         * Create an OTHER BankAccount
         * 
         * @param userId The Id of a user
         * @param bankAccountOTHER 
         */
        usersPostBankAccountOther(params: {  "userId": number; "bankAccountOTHER"?: BankAccountOtherPost; }, options?: any) {
            return UsersApiFp.usersPostBankAccountOther(params, options)(fetch, basePath);
        },
        /** 
         * Create an US BankAccount
         * In the case of USD PayOut, the author (AuthorId) of the PayOut should have their address (Address for Natural Users or HeaquartersAddress for Legal Users) completed in their User object.
         * @param userId The Id of a user
         * @param bankAccountUS BankAccountUS Object params
         */
        usersPostBankAccountUs(params: {  "userId": number; "bankAccountUS"?: BankAccountUsPost; }, options?: any) {
            return UsersApiFp.usersPostBankAccountUs(params, options)(fetch, basePath);
        },
        /** 
         * Create a Legal User
         * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
         * @param userLegal UserLegal Object params
         */
        usersPostLegal(params: {  "userLegal"?: UserLegalPost; }, options?: any) {
            return UsersApiFp.usersPostLegal(params, options)(fetch, basePath);
        },
        /** 
         * Create a Natural User
         * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
         * @param userNatural UserNatural Object params
         */
        usersPostNatural(params: {  "userNatural"?: UserNaturalPost; }, options?: any) {
            return UsersApiFp.usersPostNatural(params, options)(fetch, basePath);
        },
        /** 
         * Update a Legal User
         * Note that the LegalRepresentativeBirthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
         * @param userId The Id of a user
         * @param userLegal UserLegal Object params
         */
        usersPutLegal(params: {  "userId": number; "userLegal"?: UserLegalPut; }, options?: any) {
            return UsersApiFp.usersPutLegal(params, options)(fetch, basePath);
        },
        /** 
         * Update a Natural User
         * Note that the Birthday field is a timestamp, but be careful to ensure that the time is midnight UTC (otherwise a local time can be understood as 23h UTC, and therefore rendering the wrong date which will present problems when needing to validate the KYC identity)
         * @param userId The Id of a user
         * @param userNatural UserNatural Object params
         */
        usersPutNatural(params: {  "userId": number; "userNatural"?: UserNaturalPut; }, options?: any) {
            return UsersApiFp.usersPutNatural(params, options)(fetch, basePath);
        },
    };
};


/**
 * WalletsApi - fetch parameter creator
 */
export const WalletsApiFetchParamCreator = {
    /** 
     * View a Wallet
     * A Wallet is an object in which PayIns and Transfers from users are stored in order to collect money. You can pay into a Wallet, withdraw funds from a wallet or transfer funds from a Wallet to another Wallet.              Once a wallet is created, its Currency can not be changed
     * @param walletId The Id of a wallet
     */
    walletsGet(params: {  "walletId": number; }, options?: any): FetchArgs {
        // verify required parameter "walletId" is set
        if (params["walletId"] == null) {
            throw new Error("Missing required parameter walletId when calling walletsGet");
        }
        const baseUrl = `/v2.01/Wallets/{WalletId}`
            .replace(`{${"WalletId"}}`, `${ params["walletId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    walletsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Wallets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "Per_Page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List a Wallet&#39;s Transactions
     * 
     * @param walletId The Id of a wallet
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    walletsGetTransactionList(params: {  "walletId": number; "page"?: number; "perPage"?: number; }, options?: any): FetchArgs {
        // verify required parameter "walletId" is set
        if (params["walletId"] == null) {
            throw new Error("Missing required parameter walletId when calling walletsGetTransactionList");
        }
        const baseUrl = `/v2.01/Wallets/{WalletId}/transactions`
            .replace(`{${"WalletId"}}`, `${ params["walletId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "Page": params["page"],
            "per_page": params["perPage"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a Wallet
     * 
     * @param wallet Wallet Object params
     */
    walletsPost(params: {  "wallet"?: WalletPost; }, options?: any): FetchArgs {
        const baseUrl = `/v2.01/Wallets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["wallet"]) {
            fetchOptions.body = JSON.stringify(params["wallet"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a Wallet
     * 
     * @param walletId The Id of a wallet
     * @param wallet Wallet Object params
     */
    walletsPut(params: {  "walletId": number; "wallet"?: WalletPut; }, options?: any): FetchArgs {
        // verify required parameter "walletId" is set
        if (params["walletId"] == null) {
            throw new Error("Missing required parameter walletId when calling walletsPut");
        }
        const baseUrl = `/v2.01/Wallets/{WalletId}`
            .replace(`{${"WalletId"}}`, `${ params["walletId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["wallet"]) {
            fetchOptions.body = JSON.stringify(params["wallet"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * WalletsApi - functional programming interface
 */
export const WalletsApiFp = {
    /** 
     * View a Wallet
     * A Wallet is an object in which PayIns and Transfers from users are stored in order to collect money. You can pay into a Wallet, withdraw funds from a wallet or transfer funds from a Wallet to another Wallet.              Once a wallet is created, its Currency can not be changed
     * @param walletId The Id of a wallet
     */
    walletsGet(params: { "walletId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletResponse> {
        const fetchArgs = WalletsApiFetchParamCreator.walletsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page 
     * @param perPage 
     */
    walletsGetList(params: { "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseListWalletResponse> {
        const fetchArgs = WalletsApiFetchParamCreator.walletsGetList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List a Wallet&#39;s Transactions
     * 
     * @param walletId The Id of a wallet
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    walletsGetTransactionList(params: { "walletId": number; "page"?: number; "perPage"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TransactionResponse>> {
        const fetchArgs = WalletsApiFetchParamCreator.walletsGetTransactionList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a Wallet
     * 
     * @param wallet Wallet Object params
     */
    walletsPost(params: { "wallet"?: WalletPost;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletResponse> {
        const fetchArgs = WalletsApiFetchParamCreator.walletsPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a Wallet
     * 
     * @param walletId The Id of a wallet
     * @param wallet Wallet Object params
     */
    walletsPut(params: { "walletId": number; "wallet"?: WalletPut;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletResponse> {
        const fetchArgs = WalletsApiFetchParamCreator.walletsPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * WalletsApi - object-oriented interface
 */
export class WalletsApi extends BaseAPI {
    /** 
     * View a Wallet
     * A Wallet is an object in which PayIns and Transfers from users are stored in order to collect money. You can pay into a Wallet, withdraw funds from a wallet or transfer funds from a Wallet to another Wallet.              Once a wallet is created, its Currency can not be changed
     * @param walletId The Id of a wallet
     */
    walletsGet(params: {  "walletId": number; }, options?: any) {
        return WalletsApiFp.walletsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param page 
     * @param perPage 
     */
    walletsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
        return WalletsApiFp.walletsGetList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List a Wallet&#39;s Transactions
     * 
     * @param walletId The Id of a wallet
     * @param page The page number of results you wish to return
     * @param perPage The number of results to return per page
     */
    walletsGetTransactionList(params: {  "walletId": number; "page"?: number; "perPage"?: number; }, options?: any) {
        return WalletsApiFp.walletsGetTransactionList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a Wallet
     * 
     * @param wallet Wallet Object params
     */
    walletsPost(params: {  "wallet"?: WalletPost; }, options?: any) {
        return WalletsApiFp.walletsPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a Wallet
     * 
     * @param walletId The Id of a wallet
     * @param wallet Wallet Object params
     */
    walletsPut(params: {  "walletId": number; "wallet"?: WalletPut; }, options?: any) {
        return WalletsApiFp.walletsPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * WalletsApi - factory interface
 */
export const WalletsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * View a Wallet
         * A Wallet is an object in which PayIns and Transfers from users are stored in order to collect money. You can pay into a Wallet, withdraw funds from a wallet or transfer funds from a Wallet to another Wallet.              Once a wallet is created, its Currency can not be changed
         * @param walletId The Id of a wallet
         */
        walletsGet(params: {  "walletId": number; }, options?: any) {
            return WalletsApiFp.walletsGet(params, options)(fetch, basePath);
        },
        /** 
         * @param page 
         * @param perPage 
         */
        walletsGetList(params: {  "page"?: number; "perPage"?: number; }, options?: any) {
            return WalletsApiFp.walletsGetList(params, options)(fetch, basePath);
        },
        /** 
         * List a Wallet&#39;s Transactions
         * 
         * @param walletId The Id of a wallet
         * @param page The page number of results you wish to return
         * @param perPage The number of results to return per page
         */
        walletsGetTransactionList(params: {  "walletId": number; "page"?: number; "perPage"?: number; }, options?: any) {
            return WalletsApiFp.walletsGetTransactionList(params, options)(fetch, basePath);
        },
        /** 
         * Create a Wallet
         * 
         * @param wallet Wallet Object params
         */
        walletsPost(params: {  "wallet"?: WalletPost; }, options?: any) {
            return WalletsApiFp.walletsPost(params, options)(fetch, basePath);
        },
        /** 
         * Update a Wallet
         * 
         * @param walletId The Id of a wallet
         * @param wallet Wallet Object params
         */
        walletsPut(params: {  "walletId": number; "wallet"?: WalletPut; }, options?: any) {
            return WalletsApiFp.walletsPut(params, options)(fetch, basePath);
        },
    };
};

